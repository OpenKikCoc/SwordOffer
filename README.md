### SwordOffer
SwordOffer Solutions

[toc]



- [SwordOffer](#swordoffer)
  - [03.数组中重复的数字 [EASY]](#03%e6%95%b0%e7%bb%84%e4%b8%ad%e9%87%8d%e5%a4%8d%e7%9a%84%e6%95%b0%e5%ad%97-easy)
  - [04.二维数组中的查找 [EASY]](#04%e4%ba%8c%e7%bb%b4%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e6%9f%a5%e6%89%be-easy)
  - [05.替换空格 [EASY]](#05%e6%9b%bf%e6%8d%a2%e7%a9%ba%e6%a0%bc-easy)
  - [06.从尾到头打印链表 [EASY]](#06%e4%bb%8e%e5%b0%be%e5%88%b0%e5%a4%b4%e6%89%93%e5%8d%b0%e9%93%be%e8%a1%a8-easy)
  - [07. 重建二叉树 [MID]](#07-%e9%87%8d%e5%bb%ba%e4%ba%8c%e5%8f%89%e6%a0%91-mid)
  - [09. 用两个栈实现队列 [EASY]](#09-%e7%94%a8%e4%b8%a4%e4%b8%aa%e6%a0%88%e5%ae%9e%e7%8e%b0%e9%98%9f%e5%88%97-easy)
  - [10- I. 斐波那契数列 [EASY]](#10--i-%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%95%b0%e5%88%97-easy)
  - [10- II. 青蛙跳台阶问题 [EASY]](#10--ii-%e9%9d%92%e8%9b%99%e8%b7%b3%e5%8f%b0%e9%98%b6%e9%97%ae%e9%a2%98-easy)
  - [11. 旋转数组的最小数字 [EASY]](#11-%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%b0%8f%e6%95%b0%e5%ad%97-easy)
  - [12. 矩阵中的路径 [MID]](#12-%e7%9f%a9%e9%98%b5%e4%b8%ad%e7%9a%84%e8%b7%af%e5%be%84-mid)
  - [13. 机器人的运动范围 [MID]](#13-%e6%9c%ba%e5%99%a8%e4%ba%ba%e7%9a%84%e8%bf%90%e5%8a%a8%e8%8c%83%e5%9b%b4-mid)
  - [14- I. 剪绳子 [MID]](#14--i-%e5%89%aa%e7%bb%b3%e5%ad%90-mid)
  - [14- II. 剪绳子 II [MID]](#14--ii-%e5%89%aa%e7%bb%b3%e5%ad%90-ii-mid)
  - [15. 二进制中1的个数 [EASY]](#15-%e4%ba%8c%e8%bf%9b%e5%88%b6%e4%b8%ad1%e7%9a%84%e4%b8%aa%e6%95%b0-easy)
  - [16. 数值的整数次方 [MID]](#16-%e6%95%b0%e5%80%bc%e7%9a%84%e6%95%b4%e6%95%b0%e6%ac%a1%e6%96%b9-mid)
  - [17. 打印从1到最大的n位数 [EASY]](#17-%e6%89%93%e5%8d%b0%e4%bb%8e1%e5%88%b0%e6%9c%80%e5%a4%a7%e7%9a%84n%e4%bd%8d%e6%95%b0-easy)
  - [18. 删除链表的节点 [EASY]](#18-%e5%88%a0%e9%99%a4%e9%93%be%e8%a1%a8%e7%9a%84%e8%8a%82%e7%82%b9-easy)
  - [19. 正则表达式匹配 [HARD]](#19-%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%8c%b9%e9%85%8d-hard)
  - [20. 表示数值的字符串 [MID]](#20-%e8%a1%a8%e7%a4%ba%e6%95%b0%e5%80%bc%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2-mid)
  - [21. 调整数组顺序使奇数位于偶数前面 [EASY]](#21-%e8%b0%83%e6%95%b4%e6%95%b0%e7%bb%84%e9%a1%ba%e5%ba%8f%e4%bd%bf%e5%a5%87%e6%95%b0%e4%bd%8d%e4%ba%8e%e5%81%b6%e6%95%b0%e5%89%8d%e9%9d%a2-easy)
  - [22. 链表中倒数第k个节点 [EASY]](#22-%e9%93%be%e8%a1%a8%e4%b8%ad%e5%80%92%e6%95%b0%e7%ac%ack%e4%b8%aa%e8%8a%82%e7%82%b9-easy)
  - [24. 反转链表 [EASY]](#24-%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8-easy)
  - [25. 合并两个排序的链表 [EASY]](#25-%e5%90%88%e5%b9%b6%e4%b8%a4%e4%b8%aa%e6%8e%92%e5%ba%8f%e7%9a%84%e9%93%be%e8%a1%a8-easy)
  - [26. 树的子结构 [MID]](#26-%e6%a0%91%e7%9a%84%e5%ad%90%e7%bb%93%e6%9e%84-mid)
  - [27. 二叉树的镜像 [EASY]](#27-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e9%95%9c%e5%83%8f-easy)
  - [28. 对称的二叉树 [EASY]](#28-%e5%af%b9%e7%a7%b0%e7%9a%84%e4%ba%8c%e5%8f%89%e6%a0%91-easy)
  - [29. 顺时针打印矩阵 [EASY]](#29-%e9%a1%ba%e6%97%b6%e9%92%88%e6%89%93%e5%8d%b0%e7%9f%a9%e9%98%b5-easy)
  - [30. 包含min函数的栈 [EASY]](#30-%e5%8c%85%e5%90%abmin%e5%87%bd%e6%95%b0%e7%9a%84%e6%a0%88-easy)
  - [31. 栈的压入、弹出序列 [MID]](#31-%e6%a0%88%e7%9a%84%e5%8e%8b%e5%85%a5%e5%bc%b9%e5%87%ba%e5%ba%8f%e5%88%97-mid)
  - [32 - I. 从上到下打印二叉树 [MID]](#32---i-%e4%bb%8e%e4%b8%8a%e5%88%b0%e4%b8%8b%e6%89%93%e5%8d%b0%e4%ba%8c%e5%8f%89%e6%a0%91-mid)
  - [32 - II. 从上到下打印二叉树 II [EASY]](#32---ii-%e4%bb%8e%e4%b8%8a%e5%88%b0%e4%b8%8b%e6%89%93%e5%8d%b0%e4%ba%8c%e5%8f%89%e6%a0%91-ii-easy)
  - [32 - III. 从上到下打印二叉树 III [MID]](#32---iii-%e4%bb%8e%e4%b8%8a%e5%88%b0%e4%b8%8b%e6%89%93%e5%8d%b0%e4%ba%8c%e5%8f%89%e6%a0%91-iii-mid)
  - [33. 二叉搜索树的后序遍历序列 [MID]](#33-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97-mid)
  - [34. 二叉树中和为某一值的路径 [MID]](#34-%e4%ba%8c%e5%8f%89%e6%a0%91%e4%b8%ad%e5%92%8c%e4%b8%ba%e6%9f%90%e4%b8%80%e5%80%bc%e7%9a%84%e8%b7%af%e5%be%84-mid)
  - [35. 复杂链表的复制 [MID]](#35-%e5%a4%8d%e6%9d%82%e9%93%be%e8%a1%a8%e7%9a%84%e5%a4%8d%e5%88%b6-mid)
  - [36. 二叉搜索树与双向链表 [MID]](#36-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%8e%e5%8f%8c%e5%90%91%e9%93%be%e8%a1%a8-mid)
  - [37. 序列化二叉树 [HARD]](#37-%e5%ba%8f%e5%88%97%e5%8c%96%e4%ba%8c%e5%8f%89%e6%a0%91-hard)
  - [38. 字符串的排列 [MID]](#38-%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e6%8e%92%e5%88%97-mid)
  - [39. 数组中出现次数超过一半的数字 [EASY]](#39-%e6%95%b0%e7%bb%84%e4%b8%ad%e5%87%ba%e7%8e%b0%e6%ac%a1%e6%95%b0%e8%b6%85%e8%bf%87%e4%b8%80%e5%8d%8a%e7%9a%84%e6%95%b0%e5%ad%97-easy)
  - [40. 最小的k个数 [EASY]](#40-%e6%9c%80%e5%b0%8f%e7%9a%84k%e4%b8%aa%e6%95%b0-easy)
  - [41. 数据流中的中位数 [HARD]](#41-%e6%95%b0%e6%8d%ae%e6%b5%81%e4%b8%ad%e7%9a%84%e4%b8%ad%e4%bd%8d%e6%95%b0-hard)
  - [42. 连续子数组的最大和 [EASY]](#42-%e8%bf%9e%e7%bb%ad%e5%ad%90%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%a4%a7%e5%92%8c-easy)
  - [43. 1～n整数中1出现的次数 [MID]](#43-1n%e6%95%b4%e6%95%b0%e4%b8%ad1%e5%87%ba%e7%8e%b0%e7%9a%84%e6%ac%a1%e6%95%b0-mid)
  - [44. 数字序列中某一位的数字 [MID]](#44-%e6%95%b0%e5%ad%97%e5%ba%8f%e5%88%97%e4%b8%ad%e6%9f%90%e4%b8%80%e4%bd%8d%e7%9a%84%e6%95%b0%e5%ad%97-mid)
  - [45. 把数组排成最小的数 [MID]](#45-%e6%8a%8a%e6%95%b0%e7%bb%84%e6%8e%92%e6%88%90%e6%9c%80%e5%b0%8f%e7%9a%84%e6%95%b0-mid)
  - [46. 把数字翻译成字符串 [MID]](#46-%e6%8a%8a%e6%95%b0%e5%ad%97%e7%bf%bb%e8%af%91%e6%88%90%e5%ad%97%e7%ac%a6%e4%b8%b2-mid)
  - [47. 礼物的最大价值 [MID]](#47-%e7%a4%bc%e7%89%a9%e7%9a%84%e6%9c%80%e5%a4%a7%e4%bb%b7%e5%80%bc-mid)
  - [48. 最长不含重复字符的子字符串 [MID]](#48-%e6%9c%80%e9%95%bf%e4%b8%8d%e5%90%ab%e9%87%8d%e5%a4%8d%e5%ad%97%e7%ac%a6%e7%9a%84%e5%ad%90%e5%ad%97%e7%ac%a6%e4%b8%b2-mid)
  - [49. 丑数 [MID]](#49-%e4%b8%91%e6%95%b0-mid)
  - [50. 第一个只出现一次的字符 [EASY]](#50-%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%8f%aa%e5%87%ba%e7%8e%b0%e4%b8%80%e6%ac%a1%e7%9a%84%e5%ad%97%e7%ac%a6-easy)
  - [51. 数组中的逆序对 [HARD]](#51-%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e9%80%86%e5%ba%8f%e5%af%b9-hard)
  - [52. 两个链表的第一个公共节点 [EASY]](#52-%e4%b8%a4%e4%b8%aa%e9%93%be%e8%a1%a8%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%85%ac%e5%85%b1%e8%8a%82%e7%82%b9-easy)
  - [53 - I. 在排序数组中查找数字 I [EASY]](#53---i-%e5%9c%a8%e6%8e%92%e5%ba%8f%e6%95%b0%e7%bb%84%e4%b8%ad%e6%9f%a5%e6%89%be%e6%95%b0%e5%ad%97-i-easy)
  - [53 - II. 0～n-1中缺失的数字 [EASY]](#53---ii-0n-1%e4%b8%ad%e7%bc%ba%e5%a4%b1%e7%9a%84%e6%95%b0%e5%ad%97-easy)
  - [54. 二叉搜索树的第k大节点 [EASY]](#54-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e7%ac%ack%e5%a4%a7%e8%8a%82%e7%82%b9-easy)
  - [55 - I. 二叉树的深度 [EASY]](#55---i-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%b7%b1%e5%ba%a6-easy)
  - [55 - II. 平衡二叉树 [EASY]](#55---ii-%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91-easy)
  - [56 - II. 数组中数字出现的次数 II  [MID]](#56---ii-%e6%95%b0%e7%bb%84%e4%b8%ad%e6%95%b0%e5%ad%97%e5%87%ba%e7%8e%b0%e7%9a%84%e6%ac%a1%e6%95%b0-ii-mid)
  - [57. 和为s的两个数字 [EASY]](#57-%e5%92%8c%e4%b8%bas%e7%9a%84%e4%b8%a4%e4%b8%aa%e6%95%b0%e5%ad%97-easy)
  - [57 - II. 和为s的连续正数序列 [EASY]](#57---ii-%e5%92%8c%e4%b8%bas%e7%9a%84%e8%bf%9e%e7%bb%ad%e6%ad%a3%e6%95%b0%e5%ba%8f%e5%88%97-easy)
  - [58 - I. 翻转单词顺序 [EASY]](#58---i-%e7%bf%bb%e8%bd%ac%e5%8d%95%e8%af%8d%e9%a1%ba%e5%ba%8f-easy)
  - [58 - II. 左旋转字符串 [EASY]](#58---ii-%e5%b7%a6%e6%97%8b%e8%bd%ac%e5%ad%97%e7%ac%a6%e4%b8%b2-easy)
  - [59 - I. 滑动窗口的最大值 [EASY]](#59---i-%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e7%9a%84%e6%9c%80%e5%a4%a7%e5%80%bc-easy)
  - [59 - II. 队列的最大值 [MID]](#59---ii-%e9%98%9f%e5%88%97%e7%9a%84%e6%9c%80%e5%a4%a7%e5%80%bc-mid)
  - [60. n个骰子的点数 [EASY]](#60-n%e4%b8%aa%e9%aa%b0%e5%ad%90%e7%9a%84%e7%82%b9%e6%95%b0-easy)
  - [61. 扑克牌中的顺子 [EASY]](#61-%e6%89%91%e5%85%8b%e7%89%8c%e4%b8%ad%e7%9a%84%e9%a1%ba%e5%ad%90-easy)
  - [62. 圆圈中最后剩下的数字 [EASY]](#62-%e5%9c%86%e5%9c%88%e4%b8%ad%e6%9c%80%e5%90%8e%e5%89%a9%e4%b8%8b%e7%9a%84%e6%95%b0%e5%ad%97-easy)
  - [63. 股票的最大利润 [MID]](#63-%e8%82%a1%e7%a5%a8%e7%9a%84%e6%9c%80%e5%a4%a7%e5%88%a9%e6%b6%a6-mid)
  - [64. 求1+2+…+n [MID]](#64-%e6%b1%8212n-mid)
  - [65. 不用加减乘除做加法 [EASY]](#65-%e4%b8%8d%e7%94%a8%e5%8a%a0%e5%87%8f%e4%b9%98%e9%99%a4%e5%81%9a%e5%8a%a0%e6%b3%95-easy)
  - [66. 构建乘积数组 [EASY]](#66-%e6%9e%84%e5%bb%ba%e4%b9%98%e7%a7%af%e6%95%b0%e7%bb%84-easy)
  - [67. 把字符串转换成整数 [MID]](#67-%e6%8a%8a%e5%ad%97%e7%ac%a6%e4%b8%b2%e8%bd%ac%e6%8d%a2%e6%88%90%e6%95%b4%e6%95%b0-mid)
  - [68 - I. 二叉搜索树的最近公共祖先 [EASY]](#68---i-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88-easy)
  - [68 - II. 二叉树的最近公共祖先 [EASY]](#68---ii-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88-easy)

#### [03.数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/) [EASY]

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        unordered_map<int, bool> m;
        int len = nums.size();
        for(int i = 0; i < len; ++i) {
            if(m[nums[i]] == true) return nums[i];
            else {
                m[nums[i]] = true;
            }
        }
        return -1;
    }
// ========= another solution
    int findRepeatNumber(vector<int>& nums) {
        int len = nums.size(), tmp;
        for(int i = 0; i < len; ++i) {
            while(nums[i] != i) {
                if(nums[i] == nums[nums[i]]) return nums[i];
                tmp = nums[i];
                nums[i] = nums[tmp];
                nums[tmp] = tmp;
            }
        }
        return -1;
    }
// =========
};
```



```python
# python3
```



#### [04.二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/) [EASY]

```c++
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        if(!m) return false;
        int n = matrix[0].size();
        int u = 0, r = n-1;
        while(u<m&&r>=0) {
            if(matrix[u][r] > target) --r;
            else if (matrix[u][r] < target) ++u;
            else return true;
        }
        return false;
    }
};
```



```python
# python3
```



#### [05.替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/) [EASY]

```c++
class Solution {
public:
    string replaceSpace(string s) {
        int len = s.size();
        string res;
        for(int i = 0; i < len; ++i) {
            if (s[i] == ' ') {
                res+= "%20";
            } else res.push_back(s[i]);
        }
        return res;
    }
};
```



```python
# python3
```



#### [06.从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/) [EASY]

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        vector<int> res;
        while(head != nullptr) {
            res.push_back(head->val);
            head = head->next;
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```



```python
# python3
```



#### [07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/) [MID]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* helper(unordered_map<int, int>& h, vector<int>& pre, int s0, int e0, int s1) {
        if(s0 > e0) return nullptr;
        // 父节点 父节点在中序序列的idx
        int mid = pre[s1], idx = h[mid], leftLen = idx-s0;
        TreeNode* node = new TreeNode(mid);
        node->left = helper(h, pre, s0, idx-1, s1+1);
        node->right = helper(h, pre, idx+1, e0, s1+1+leftLen);
        return node;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        unordered_map<int, int> hash;
        for(int i = 0; i < n; ++i) hash[inorder[i]] = i;
        return helper(hash, preorder, 0, n-1, 0);
    }
};
```



```python
# python3
```



#### [09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/) [EASY]

```c++
class CQueue {
    stack<int> in, out;
public:
    CQueue() {
    }
    
    void appendTail(int value) {
        in.push(value);
    }
    
    int deleteHead() {
        if(out.size()) {
            int res = out.top();
            out.pop();
            return res;
        } else if(in.size()) {
            while(in.size()>1) {
                int v = in.top();
                in.pop();
                out.push(v);
            }
            int res = in.top();
            in.pop();
            return res;
        } else return -1;
    }
};

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue* obj = new CQueue();
 * obj->appendTail(value);
 * int param_2 = obj->deleteHead();
 */
```



```python
# python3
```



#### [10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/) [EASY]

```c++
class Solution {
public:
    int mod = 1e9+7;
    int fib(int n) {
        if(n <= 1) return n;
        int a = 0, b = 1, tmp;
        for(int i = 2; i <= n; ++i) {
            tmp = a;
            a = b%mod;
            b = (tmp + b)%mod;
        }
        return b;
    }
};
```



```python
# python3
```



#### [10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/) [EASY]

```c++
// 同上
```



```python
# python3
```



#### [11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/) [EASY]

```c++
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int n = numbers.size();
        int l = 0, r = n-1;
        while(l <= r) {
            while(l <= r && numbers[l] == numbers[r]) --r;
            if(l > r || numbers[l] < numbers[r]) break;
            int mid = l + (r-l)/2;
            if(numbers[mid] >= numbers[l]) l = mid+1;	// must mid > r
            else r = mid;
        }
        return numbers[l];
    }
};
```



```python
# python3
```



#### [12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/) [MID]

```c++
class Solution {
public:
    int wordlen;
    int m, n;
    int dx[4] = {0, -1, 1, 0}, dy[4] = {-1, 0, 0, 1};
    bool dfs(int x, int y, int idx, vector<vector<bool>>& vis, vector<vector<char>>& board, string word) {
        if (board[x][y] != word[idx]) return false;
        if (idx == wordlen-1) return true;
        for(int i = 0; i < 4; ++i) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx >= 0 && nx < m && ny >= 0 && ny <n) {
                if (vis[nx][ny]) continue;
                vis[nx][ny] = true;
                if (dfs(nx, ny, idx+1, vis, board, word)) return true;
                vis[nx][ny] = false;
            }
        }
        return false;
    }
    bool exist(vector<vector<char>>& board, string word) {
        if (board.empty()) return false;
        wordlen = word.size();
        m = board.size();
        n = board[0].size();
        vector<vector<bool>> vis(m, vector<bool>(n));
        for(int i = 0; i < m; ++i) {
            for( int j = 0; j < n; ++j) {
                vis[i][j] = true;
                if (dfs(i, j, 0, vis, board, word)) return true;\
                vis[i][j] = false;
            }
        }
        return false;
    }
};
```



```python
# python3
```



#### [13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/) [MID]

```c++
class Solution {
public:
    int res = 0;
    int dx[4] = {-1, 0, 0, 1}, dy[4] = {0, -1, 1, 0};
    void dfs(int x, int y, vector<vector<bool>>& vis, int m, int n, int k) {
        if(!check(x, y, k)) return;
        res++;
        for(int i = 0; i < 4; ++i) {
            int nx = x + dx[i], ny = y + dy[i];
            if(nx < 0 || nx >= m || ny < 0 || ny >= n || vis[nx][ny]) continue;
            vis[nx][ny] = true;
            dfs(nx, ny, vis, m, n, k);
        }
        return;
    }
    bool check(int x, int y, int k) {
        int cnt = 0;
        while(x) {
            cnt+= x%10;
            x/=10;
        }
        while(y) {
            cnt += y%10;
            y/=10;
        }
        return cnt <= k;
    }
    int movingCount(int m, int n, int k) {
        vector<vector<bool>> vis(m, vector<bool>(n));
        res = 0;
        vis[0][0] = true;
        dfs(0, 0, vis, m, n, k);
        return res;
    }
};
```



```python
# python3
```



#### [14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/) [MID]

```c++
class Solution {
public:
    int cuttingRope(int n) {
        if(n<=3) return n-1;
        int res = 1;
        if(n%3 == 1) {
            res *= 4;
            n -= 4;
        }
        while(n >= 3) {
            res *= 3;
            n -= 3;
        }
        if(n == 2) res *= 2;
        return res;
    }
};
```



```python
# python3
```



#### [14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/) [MID]

```c++
class Solution {
public:
    long long mod = 1e9+7;
    int cuttingRope(int n) {
        if(n <= 3) return n-1;
        long long res = 1;
        if(n%3 == 1) {
            res *= 4;
            n -= 4;
        }
        while(n>=3) {
            res *= 3;
            res %= mod;
            n -= 3;
        }
        if (n == 2) res *= 2;
        return res % mod;    
    }
};
```



```python
# python3
```



#### [15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/) [EASY]

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int res = 0;
        while(n) {
            n = n&(n-1);
            ++res;
        }
        return res;
    }
};
```



```python
# python3
```



#### [16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/) [MID]

```c++
class Solution {
public:
    double myPow(double x, int n) {
      	// case
        if(x == 1) return 1;
        else if(x == -1) return n&1?-1:1;
        if(n == INT_MIN) return 0;
        int N = n;
        if (n < 0) {
            N = -N;
            x = 1.0/x;
        }
        double res = 1;
        while(N) {
            if (N&1) res *= x;
            x *= x;
            N >>= 1;
        }
        return res;
    }
};
```



```python
# python3
```



#### [17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/) [EASY]

```c++
class Solution {
public:
    vector<int> printNumbers(int n) {
        int tot = 1;
        while(n--) tot *= 10;
        vector<int> res;
        for(int i = 1; i < tot; ++i) {
            res.push_back(i);
        }
        return res;
    }
};
```



```python
# python3
```



#### [18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/) [EASY]

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* pre = dummy, *now = dummy->next;
        while(now != nullptr && now->val != val) {
            pre = pre->next;
            now = now->next;
        }
        if(now == nullptr) return dummy->next;
        pre->next = now->next;
        return dummy->next;
    }
};
```



```python
# python3
```



#### [19. 正则表达式匹配](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/) [HARD]

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size();
        vector<vector<bool>> dp(m+1, vector<bool>(n+1));
        dp[0][0] = true;
        for(int i = 2; i <= n; ++i)
            if(p[i-1] == '*') dp[0][i] = dp[0][i-2];
        for(int i = 1; i <= m; ++i) {
            for(int j = 1; j <= n; ++j) {
                if(s[i-1] == p[j-1] || p[j-1] == '.') {
                		// s[i-1] p[j-1] 可以匹配
                    dp[i][j] = dp[i-1][j-1];
                } else if (p[j-1] == '*') {
                  	// 此时显然s[i-1] p[j-1] 不可以匹配 考虑使用p[j-2]位置
                  	// if 不能匹配->不使用p[j-2]与p[j-1]组成的模式串
                  	// else 能匹配->使用p[j-2]与p[j-1]组成的模式串1或多次
                    if(p[j-2] != '.' && p[j-2] != s[i-1]) dp[i][j] = dp[i][j-2];
                    else dp[i][j] = dp[i][j-2] || dp[i-1][j];
                }
            }
        }
        return dp[m][n];
    }
};
```



```python
# python3
```



#### [20. 表示数值的字符串](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/) [MID]

```c++
class Solution {
public:
    bool isNumber(string s) {
        int len = s.size();
      	// d1:整数部分 d2:小数部分 d3:幂次部分
        int p = 0, d1 = 0, dot = 0, d2 = 0, e = 0, d3 = 0;
        while(p<len && s[p] == ' ') ++p;
        if(s[p] == '-' || s[p] == '+') ++p;
        while(p < len && s[p] >= '0' && s[p] <= '9') d1 = ++p;
        if(p < len && s[p] == '.') {
            dot = ++p;
            while(p<len && s[p] >= '0' && s[p] <= '9') d2 = ++p;
        }
        if(dot && !d1 && !d2) return false;
        if(p<len && (d1||d2) && s[p]=='e') e = ++p;
        if(p<len && e && (s[p]=='+'|s[p]=='-')) ++p;
        while(p<len && s[p] >= '0' && s[p] <= '9') d3 = ++p;
        if(e && (!(d1||d2) || !d3)) return false;
        while(p<len && s[p] == ' ') ++p;
        if(!d1 && !d2) return false;
        return p==len;
    }
};
```



```python
# python3
```



#### [21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/) [EASY]

```c++
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        int len = nums.size();
        if(len <= 1) return nums;
        int l = 0, r = len-1;
        while(l < r) {
            while(l < r && nums[l]&1) ++l;
            if(l >= r) break;
            while(l < r && (nums[r]%2 == 0)) --r;
            // attention 不能写nums[r] & 1 == 0
            if(l >= r) break;
            swap(nums[l++], nums[r--]);
        }
        return nums;
    }
};
```



```python
# python3
```



#### [22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/) [EASY]

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* slow = dummy, *fast = dummy;
        while(k--) {
            fast = fast->next;
        }
        while(fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next;
        }
        return slow->next;
    }
  	// another solution
  	ListNode* getKthFromEnd(ListNode* head, int k) {
      	ListNode* slow = head, *fast = head;
      	while(k--) fast = fast->next;
      	while(fast) {
          	slow = slow->next;
          	fast = fast->next;
        }
      	return slow;
    }
};
```



```python
# python3
```



#### [24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/) [EASY]

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *cur = head, *pre = nullptr, *next;
        while(cur) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
};
```



```python
# python3
```



#### [25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/) [EASY]

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(-1);
        ListNode* pre = dummy;
        while(l1 != nullptr && l2 != nullptr) {
            if(l1->val <= l2->val) {
                pre->next = l1;
                pre = l1;
                l1 = l1->next;
            } else {
                pre->next = l2;
                pre = l2;
                l2 = l2->next;
            }
        }
        if(l1 == nullptr) pre->next = l2;
        else pre->next = l1;
        return dummy->next;
    }
/*
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == nullptr) return l2;
        else if (l2 == nullptr) return l1;
        else if (l1->val < l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        } else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
*/
};
```



```python
# python3
```



#### [26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/) [MID]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool helper(TreeNode* A, TreeNode* B) {
        if(!B) return true;
        if(!A) return false;
        if(A->val != B->val) return false;
        return helper(A->left, B->left) && helper(A->right, B->right);
    }
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if(!B || !A) return false;
        if(A->val == B->val) return helper(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right, B);
        return isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }
};
```



```python
# python3
```



#### [27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/) [EASY]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(!root) return root;
        TreeNode* l, *r;
        l = mirrorTree(root->right);
        r = mirrorTree(root->left);
        root->left = l;
        root->right = r;
        return root;
    }
};
```



```python
# python3
```



#### [28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/) [EASY]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool helper(TreeNode* l, TreeNode* r) {
        if(!l && !r) return true;
        else if(!l || !r) return false;
        return l->val == r->val && helper(l->left, r->right) && helper(l->right, r->left);
    }
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return helper(root->left, root->right);
    }
};
```



```python
# python3
```



#### [29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/) [EASY]

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        int m = matrix.size();
        if(!m) return res;
        int n = matrix[0].size();
        int u = 0, d = m-1, l = 0, r = n-1;
        while(u<=d && l <=r) {
            for(int i = l; i <= r; ++i) res.push_back(matrix[u][i]);
            if(++u > d) break;
            for(int i = u; i <= d; ++i) res.push_back(matrix[i][r]);
            if(--r < l) break;
            for(int i = r; i >= l; --i) res.push_back(matrix[d][i]);
            if(--d < u) break;
            for(int i = d; i >= u; --i) res.push_back(matrix[i][l]);
            if(++l > r) break;
        }
        return res;
    }
};
```



```python
# python3
```



#### [30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/) [EASY]

```c++
class MinStack {
    stack<int> s, mins;
public:
    /** initialize your data structure here. */
    MinStack() {
    }
    
    void push(int x) {
        if(s.empty() || x <= mins.top()) mins.push(x);
        else mins.push(mins.top());
        s.push(x);
    }
    
    void pop() {
        s.pop();
        mins.pop();
    }
    
    int top() {
        return s.top();
    }
    
    int min() {
        return mins.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->min();
 */
```



```python
# python3
```



#### [31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/) [MID]

```c++
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        int m = pushed.size(), n = popped.size();
        if(m != n) return false;
        int p = 0;
        stack<int> s;
        for(int i = 0; i < n; ++i) {
            s.push(pushed[i]);
            while(!s.empty() && s.top() == popped[p]) {
                s.pop();
                ++p;
            }
        }
        return p == n;
    }
};
```



```python
# python3
```



#### [32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/) [MID]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        vector<int> res;
        if(!root) return res;
        queue<TreeNode*> q;
        q.push(root);
        TreeNode* v;
        while(!q.empty()) {
            v = q.front();
            q.pop();
            res.push_back(v->val);
            if(v->left) q.push(v->left);
            if(v->right) q.push(v->right);
        }
        return res;
    }
};
```



```python
# python3
```



#### [32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/) [EASY]

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(!root) return res;
        queue<TreeNode*> q;
        q.push(root);
        TreeNode* v;
        while(!q.empty()) {
            int tot = q.size();
            vector<int> tmp;
            for(int i = 0; i < tot; ++i) {
                v = q.front();
                tmp.push_back(v->val);
                q.pop();
                if(v->left) q.push(v->left);
                if(v->right) q.push(v->right);
            }
            res.push_back(tmp);
        }
        return res;
    }
};
```



```python
# python3
```



#### [32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/) [MID]

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(!root) return res;
        stack<TreeNode*> sl, sr;
        sl.push(root);
        TreeNode* v;
        while(!sl.empty() || !sr.empty()) {
            vector<int> tmp;
            if(sl.empty()) {
                int tot = sr.size();
                for(int i = 0; i < tot; ++i) {
                    v = sr.top();
                    sr.pop();
                    tmp.push_back(v->val);
                    if(v->right) sl.push(v->right);
                    if(v->left) sl.push(v->left);
                }
            } else {
                int tot = sl.size();
                for(int i = 0; i < tot; ++i) {
                    v = sl.top();
                    sl.pop();
                    tmp.push_back(v->val);
                    if(v->left) sr.push(v->left);
                    if(v->right) sr.push(v->right);
                }
            }
            res.push_back(tmp);
        }
        return res;
    }
};
```



```python
# python3
```



#### [33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/) [MID]

[单调栈解法](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/dan-diao-di-zeng-zhan-by-shi-huo-de-xia-tian/)

```c++
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        int n = postorder.size();
        if(n<=1) return true;
        stack<int> s;
        int pre = INT_MAX;
        for(int i = n-1; i >= 0; --i) {
            if(postorder[i] > pre) {
                return false;
            }
            while(!s.empty() && postorder[i] < s.top()) {
                pre = s.top();
                s.pop();
            }
            s.push(postorder[i]);
        }
        return true;
    }
};
```



```python
# python3
```



#### [34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/) [MID]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void helper(TreeNode* root, int target) {
        if(!root) return;
        path.push_back(root->val);
        if(root->val == target && !root->left && !root->right) res.push_back(path);
        helper(root->left, target-root->val);
        helper(root->right, target-root->val);
        path.pop_back(); 
    }
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        helper(root, sum);
        return res;
    }
};
```



```python
# python3
```



#### [35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/) [MID]

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(!head) return head;
        Node* p = head;
        while(p) {
            Node* n = new Node(p->val);
            n->next = p->next;
            n->random = p->random;
            p->next = n;
            p = n->next;
        }
        p = head;
        while(p) {
            if(p->next->random) p->next->random = p->next->random->next;
            p = p->next->next;
        }
        Node* oldp = head, *newp = head->next;
        Node* newl = newp;
        while(oldp) {
            oldp->next = oldp->next->next;
            if(newp->next) newp->next = newp->next->next;
            oldp = oldp->next;
            newp = newp->next;
        }
        return newl;
    }
};
```



```python
# python3
```



#### [36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/) [MID]

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;

    Node() {}

    Node(int _val) {
        val = _val;
        left = NULL;
        right = NULL;
    }

    Node(int _val, Node* _left, Node* _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
public:
    void helper(Node* root, Node*& head, Node*& pre) {
        if(!root) return;
        helper(root->left, head, pre);
        if(!head) {
            head = root;	// 初始化
            pre = root;
        } else {
            pre->right = root;
            root->left = pre;
            pre = root;
        }
        helper(root->right, head, pre);
    }
    Node* treeToDoublyList(Node* root) {
        if(!root) return root;
        Node *head = nullptr,  *pre = nullptr;
        helper(root, head, pre);
        head->left = pre;
        pre->right = head;
        return head;
    }
};
```



```python
# python3
```



#### [37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/) [HARD]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        ostringstream out;
        queue<TreeNode*> q;
        q.push(root);
        TreeNode* tmp;
        while(!q.empty()) {
            tmp = q.front();
            q.pop();
            if(tmp != nullptr) {
                out << tmp->val<<" ";
                q.push(tmp->left);
                q.push(tmp->right);
            } else {
                out << "null ";
            }
        }
        return out.str();
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream in(data);
        string val;
        vector<TreeNode*> vec;
        while(in>>val) {
            if(val == "null") {
                vec.push_back(nullptr);
            } else vec.push_back(new TreeNode(stoi(val)));
        }
        int j = 1;
        for(int i = 0; i < vec.size(); ++i) {
            if(vec[i] == nullptr) continue;
            if(j<vec.size()) vec[i]->left = vec[j++];
            if(j<vec.size()) vec[i]->right = vec[j++];
        }
        return vec[0];
    }
};
```



```python
# python3
```



#### [38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/) [MID]

```c++
class Solution {
public:
    void dfs(vector<string>& res, string s, string& track, vector<bool>& vis) {
        if(track.size() == s.size()) {
            res.push_back(track);
            return;
        }
        for(int i = 0; i < s.size(); ++i) {
            if(vis[i]) continue;
            if(i>0 && vis[i-1] && s[i-1] == s[i]) continue;
            vis[i] = true;
            track.push_back(s[i]);
            dfs(res, s, track, vis);
            track.pop_back();
            vis[i] = false;
        }
    }
    vector<string> permutation(string s) {
        vector<string> res;
        if(s.empty()) return res;
        sort(s.begin(), s.end());
        int n = s.size();
        vector<bool> vis(n, false);
        string track;
        dfs(res, s, track, vis);
        return res;
    }
};
```



```python
# python3
```



#### [39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/) [EASY]

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int n = nums.size();
        int value = nums[0], votes = 1;
        for(int i = 1; i < n; ++i) {
            if(nums[i] == value) ++votes;
            else {
                votes?--votes:(value = nums[i],votes = 1);
                //if(votes) --votes;
                //else value = nums[i], votes = 1;
            }
       }
       return value;
    }
};
```



```python
# python3
```



#### [40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/) [EASY]

```c++
class Solution {
public:
    int partition(vector<int>& nums, int l, int r) {
        int pivot = nums[l];	// privot = nums[rand((r-l)%l+l)]
        while(l<r) {
            while(l < r && nums[r] >= pivot) --r;
            nums[l] = nums[r];
            while(l < r && nums[l] <= pivot) ++l;
            nums[r] = nums[l];
        }
        nums[l] = pivot;
        return l;
    }
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        int len = arr.size();
        vector<int> res;
        int l = 0, r = len-1;
        while(l<=r) {
            int index = partition(arr, l, r);
            if(index == k-1) {
                for(int i = 0; i < k; ++i) res.push_back(arr[i]);
                return res;
            } else if(index < k) {
                l = index + 1;
            } else r = index - 1;
        }
        return res;
    }
};
```



```python
# python3
```



#### [41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/) [HARD]

```c++
class MedianFinder {
    priority_queue<int> lo;                              // 大顶堆 都比中位数小
    priority_queue<int, vector<int>, greater<int>> hi;   // 小顶堆
public:
    /** initialize your data structure here. */
    MedianFinder() {
    }
    
    void addNum(int num) {
        lo.push(num);
        hi.push(lo.top());
        lo.pop();
        if(lo.size() < hi.size()) {
            lo.push(hi.top());
            hi.pop();
        }
    }
    
    double findMedian() {
        return lo.size() > hi.size() ? (double)lo.top() : (lo.top() + hi.top())*0.5;
    }
};
```



```python
# python3
```



#### [42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/) [EASY]

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        if(!n) return 0;
        int res = INT_MIN, sum = 0;
        for(int i = 0; i < n; ++i) {
            sum = max(nums[i], nums[i] + sum);
            res = max(res, pre);
        }
        return res;
    }
};
```



```python
# python3
```



#### [43. 1～n整数中1出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/) [MID]

```c++
class Solution {
public:
    int countDigitOne(int n) {
        int res = 0;
        long long base = 1;
        while(base <= n) {
            int t = (n/base)%10;
            if(t == 0) res += n/(base*10)*base; // front
            else if(t == 1) res += n/(base*10)*base + n%base + 1;
            else res += (n/(base*10)+1)*base;
            base *= 10;
        }
        return res;
    }
};
```



```python
# python3
```



#### [44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/) [MID]

```c++
class Solution {
public:
    int findNthDigit(int n) {
        if(n < 10) return n;
        int base = 1;
        // 0-9 10-99 100-999
        // 9 90*2 900*3
        while(n > 9*pow(10, base-1)*base){
            n -= 9*pow(10, base-1)*base;
            ++base;
        }
        // pow(10, base-1) 为该位宽的第一个数
        int value = pow(10, base-1)+n/base;
        int mod = n%base;
        if(mod) return (value/(int)pow(10, base-mod))%10;// 当前数的某一位
        return (value-1)%10;    // 上个数的末尾
    }
};
```



```python
# python3
```



#### [45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/) [MID]

```c++
class Solution {
public:
    string minNumber(vector<int>& nums) {
        auto cmp = [](string sa, string sb){return sa+sb < sb+sa;};
        vector<string> t;
        for(auto v : nums) t.push_back(to_string(v));
        sort(t.begin(), t.end(), cmp);
        string res;
        for(auto s : t) res+=s;
        return res;
    }
};
```



```python
# python3
```



#### [46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/) [MID]

```c++
class Solution {
public:
    int translateNum(int num) {
        string v = to_string(num);
        int n = v.size();
        if(n <= 1) return 1;
        vector<int> dp(n+1);
        dp[1] = 1;dp[0] = 1;
        for(int i = 2; i <= n; ++i) {
            dp[i] = dp[i-1];
            if(v[i-2] == '1' && v[i-1] >= '0' && v[i-1] <= '9') {
                dp[i] += dp[i-2];
            }
            else if(v[i-2] == '2' && v[i-1] >= '0' && v[i-1] <= '5') {
                dp[i] += dp[i-2];
            }
        }
        return dp[n];
    }
};
```



```python
# python3
```



#### [47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/) [MID]

```c++
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> dp(n+1);
        for(int i = 0; i < n; ++i) dp[i+1] = dp[i] + grid[0][i];
        for(int i = 1; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                dp[j+1] = max(dp[j], dp[j+1]) + grid[i][j];
            }
        }
        return dp[n];
    }
};
```



```python
# python3
```



#### [48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/) [MID]

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int> m(300, -1);
        int res = 0, n = s.size(), l = -1;
        for(int i = 0; i < n; ++i) {
            if(m[s[i]] > l) {
                l = m[s[i]];
            }
            res = max(res, i-l);
            m[s[i]] = i;
        }
        return res;
    }
};
```



```python
# python3
```



#### [49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/) [MID]

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        int two = 0, three = 0, five = 0;
        vector<long long> ugly;
        ugly.push_back(1ll);
        long long v = 1;
        while(--n) {
            v = min(ugly[two]*2, ugly[three]*3);
            v = min(v, ugly[five]*5);
            ugly.push_back(v);
            if(v%2==0) ++two;
            if(v%3==0) ++three;
            if(v%5==0) ++five;
        }
        return v;
    }
};
```



```python
# python3
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        dp,a,b,c=[1]*n,0,0,0
        dp[0]=1
        for i in range(1,n):
            tmp=min(dp[i]*2,dp[i]*3,dp[i]*5)
            if tmp==dp[i]*2:a+=1
            if tmp==dp[i]*3:b+=1
            if tmp==dp[i]*5:c+=1
            dp[i]=tmp
        return dp[-1]
```



#### [50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/) [EASY]

```c++
class Solution {
public:
    char firstUniqChar(string s) {
        int n = s.size();
        if(!n) return ' ';
        vector<int> cnt(26);
        for(int i = 0; i < n; ++i) {
            ++cnt[s[i]-'a'];
        }
        for(int i = 0; i < n; ++i) {
            if(cnt[s[i]-'a'] == 1) return s[i];
        }
        return ' ';
    }
};
```



```python
# python3
```



#### [51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/) [HARD]

```c++
class Solution {
public:
    int mergeSort(vector<int>& nums, vector<int>& tmp, int l, int r) {
        if(l >= r) return 0;
        int mid = l + (r-l)/2;
        int cnt = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid+1, r);
        int i = l, j = mid+1, pos = l;
        while(i<=mid && j<=r) {
            if(nums[i] <= nums[j]) {
                tmp[pos++] = nums[i++];
            } else {
                cnt += mid + 1 - i;
                tmp[pos++] = nums[j++];
            }
        }
        for(int k = i; k <= mid; ++k) tmp[pos++] = nums[k];
        for(int k = j; k <= r; ++k) tmp[pos++] = nums[k];
        copy(tmp.begin()+l, tmp.begin()+r+1, nums.begin()+l);
        return cnt;
    }
    int reversePairs(vector<int>& nums) {
        int n = nums.size();
        vector<int> tmp(n);
        return mergeSort(nums, tmp, 0, n-1);
    }
};
```



```python
# python3
```



#### [52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/) [EASY]

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* l1 = headA, *l2 = headB;
        while(l1 != l2) {
            l1 = l1 ? l1->next:headB;
            l2 = l2 ? l2->next:headA;
        }
        return l1;
    }
};
```



```python
# python3
```



#### [53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/) [EASY]

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        if(!n) return 0;
      
        int l = 0, r = n-1, s, t;
        while(l<=r) {
            int mid = l + (r-l)/2;
            if(nums[mid] < target) l = mid+1;
            else r = mid-1;
        }
        if(l >= n || nums[l] != target) s = -1;
        else s = l;
        if(s == -1) return 0;
      
        l = 0, r = n-1;
        while(l<=r) {
            int mid = l + (r-l)/2;
            if(nums[mid] <= target) l = mid+1;
            else r = mid-1;
        }
        if(r < 0 || nums[r] != target) t = -1;
        else t = r;
      	
        return t-s+1;
    }
};
```



```python
# python3
```



#### [53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/) [EASY]

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int target = (n+1)*n/2;
        int tot = 0;
        for(auto v : nums) tot += v;
        return target - tot;
    }
  	// another
  	int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int l = 0, r = n-1;
        while(l <= r) {
          	int mid = l + (r-l)/2;
          	if(nums[mid] == mid) l = mid + 1;
          	else r = mid - 1;
        }
        return l;
    }
};
```



```python
# python3
```



#### [54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/) [EASY]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int kthLargest(TreeNode* root, int k) {
        stack<TreeNode*> st;
        int cnt = 0;
        while(!st.empty() || root) {
            while(root) {
                st.push(root);
                root = root->right;
            }
            root = st.top();
            st.pop();
            ++cnt;
            if(cnt == k) return root->val;
            root = root->left;
        }
        return 0;
    }
};
```



```python
# python3
```



#### [55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/) [EASY]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```



```python
# python3
```



#### [55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/) [EASY]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int helper(TreeNode* root) {
        if(!root) return 0;
        int left = helper(root->left);
        if(left == -1) return -1;
        int right = helper(root->right);
        if(right == -1) return -1;
        return abs(left - right)<=1 ? max(left, right)+1 : -1; 
    }
    bool isBalanced(TreeNode* root) {
        if(!root) return true;
        return helper(root) != -1;
    }
};
```



```python
# python3
```



#### [56 - II. 数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)  [MID]

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(int i = 0; i < 32; ++i) {
            int p = 1 << i;
            int cnt = 0;
            for(auto v : nums) {
                if(v&p) ++cnt;
            }
            if(cnt%3) res |= p;
        }
        return res;
    }
};
```



```python
# python3
```



#### [57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/) [EASY]

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        vector<int> res;
        if(!n) return res;
        int l = 0, r = n-1;
        while(l <= r) {
            if(nums[l] + nums[r] == target) {
                res.push_back(nums[l]);
                res.push_back(nums[r]);
                return res;
            } else if (nums[l] + nums[r] < target) {
                ++l;
            } else --r;
        }
        return res;
    }
};
```



```python
# python3
```



#### [57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/) [EASY]

```c++
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        vector<vector<int>> res;
        if(target == 1) return res;
        int l = 1, r = 1, v;
        while(l <= target/2) {
            int sum = (l+r)*(r-l+1)/2;
            if(sum == target) {
                vector<int> t;
                for(int i = l; i<=r; ++i) t.emplace_back(i);
                res.emplace_back(t);
                ++l;
            } else if(sum < target) ++r;
            else ++l;
        }
        return res;
    }
};
```



```python
# python3
```



#### [58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/) [EASY]

```c++
class Solution {
public:
    string reverseWords(string s) {
        int n = s.size(), cnt = 0;
        string res;
        for(int i = n-1; i >= 0; --i) {
            if(s[i] == ' ') {
                if(!cnt) continue;
                res += s.substr(i+1, cnt) + " ";
                cnt = 0;
            } else ++cnt;
        }
        if(cnt) res += s.substr(0, cnt) + " ";
        if(res.size()>0) res.erase(res.size()-1,1);
        return res;
    }
/*
    string reverseWords(string s) {
        int n = s.size(), cnt = 0;
        string res, sub;
        bool f = true;
        for(int i = n-1; i >= 0; --i) {
            if(s[i] == ' ') {
                if(cnt==0) continue;
                if(f) f = false;
                else res.push_back(' ');
                res += s.substr(i+1, cnt);
                cnt = 0;
            } else ++cnt;
        }
        if(cnt) {
            if(!f) res.push_back(' ');
            res += s.substr(0, cnt);
        }
        return res;
    }
*/
};
```



```python
# python3
```



#### [58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/) [EASY]

```c++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        reverse(s.begin(), s.begin()+n);
        reverse(s.begin()+n, s.end());
        reverse(s.begin(), s.end());
        return s;
    }
};
```



```python
# python3
```



#### [59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/) [EASY]

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;
        deque<int> dq;		// 保存下标
        int n = nums.size();
        for(int i = 0; i < n; ++i) {
            while(!dq.empty() && dq.front() <= i-k) {
                dq.pop_front();
            }
            while(!dq.empty() && nums[dq.back()] < nums[i]) dq.pop_back();
            dq.push_back(i);
            if(i >= k-1) res.push_back(nums[dq.front()]);
        }
        return res;
    }
};
```



```python
# python3
```



#### [59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/) [MID]

```c++
class MaxQueue {
public:
    queue<int> q;
    deque<int> mq;   // mq单调递减
    MaxQueue() {
    }
    
    int max_value() {
        if(q.empty()) return -1;
        return mq.front();
    }
    
    void push_back(int value) {
        q.push(value);
        while(!mq.empty() && mq.back() < value) mq.pop_back();
        mq.push_back(value);
    }
    
    int pop_front() {
        if(q.empty()) return -1;
        int v = q.front();
        q.pop();
        if(v >= mq.front()) mq.pop_front();
        return v;
    }
};
```



```python
# python3
```



#### [60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/) [EASY]

```c++
class Solution {
public:
    vector<double> twoSum(int n) {
        vector<vector<int>> dp(15, vector<int>(70));
        for(int i = 1; i <= 6; ++i) dp[1][i] = 1;
        for(int i = 2; i <= n; ++i) {
            for(int j = 1*i; j <= 6*i; ++j) {
                for(int k = 1; k <= 6; ++k) {
                    if(j - k <= 0) break;
                    dp[i][j] += dp[i-1][j-k];
                }
            }
        }
        int all = pow(6, n);
        vector<double> res;
        for(int i = n; i <= 6*n; ++i) {
            res.push_back(dp[n][i]*1.0/all);
        }
        return res;
    }
};
```



```python
# python3
```



#### [61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/) [EASY]

```c++
class Solution {
public:
    bool isStraight(vector<int>& nums) {
        int minv = INT_MAX, maxv = INT_MIN;
        vector<bool> vis(15);
        for(auto v : nums) {
            if(v) {
                if(vis[v]) return false;
                else vis[v] = true;
                minv = min(v, minv);
                maxv = max(v, maxv);
            }
        }
        return (maxv - minv) < 5;
    }
};
```



```python
# python3
```



#### [62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/) [EASY]

```c++
class Solution {
public:
    int lastRemaining(int n, int m) {
        int ans = 0;
        // 最后一轮剩下2个人，所以从2开始反推
        for (int i = 2; i <= n; i++) {
            ans = (ans + m) % i;
        }
        return ans;
    }
};
```



```python
# python3
```



#### [63. 股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/) [MID]

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minv = INT_MAX, res = 0;
        for(auto v : prices) {
            if(minv == INT_MAX) minv = v;
            res = max(res, v-minv);
            minv = min(minv, v);
        }
        return res;
    }
};
```



```python
# python3
```



#### [64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/) [MID]

```c++
class Solution {
public:
    int sumNums(int n) {
        n && (n += sumNums(n-1));
        return n;
    }
};
```



```python
# python3
```



#### [65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/) [EASY]

```c++
class Solution {
public:
    int add(int a, int b) {
        while (b) {
            int carry = (unsigned int)(a & b) << 1;
            a ^= b;		// 求和
            b = carry;
        }
        return a;
    }
};
```



```python
# python3
```



#### [66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/) [EASY]

```c++
class Solution {
public:
    vector<int> constructArr(vector<int>& a) {
        int n = a.size();
        vector<int> b(n, 1);
        for(int i = 1; i < n; ++i) {
            b[i] = b[i-1] * a[i-1]; // b[1] = a[0]; b[n-1] = ...*a[n-2];
        }
        for(int i = n-2; i >= 0; --i) {
            a[i] = a[i] * a[i+1];
            b[i] = b[i] * a[i+1];
        }
        /*
        for(int i = 1; i < n; ++i) {
            a[n-i-1] = a[n-i-1] * a[n-i];
        }
        for(int i = 0; i < n-1; ++i) {
            b[i] *= a[i+1];
        }
        */
        return b;
    }
};
```

#### [67. 把字符串转换成整数](https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/) [MID]

```c++
class Solution {
public:
    int strToInt(string str) {
        int n = str.size();
        if(!n) return 0;
        int p = 0, flag = 1;
        while(str[p] == ' ') ++p;
        if(str[p] == '-') {
            flag = -1;
            ++p;
        } else if(str[p] == '+') ++p;
        int res = 0, v;
        while(str[p] >= '0' && str[p] <= '9') {
            v = str[p]-'0';
            if(res>INT_MAX/10 || (res==INT_MAX/10 && str[p]-'0'>7)) return INT_MAX;
            else if(res<INT_MIN/10 || (res==INT_MIN/10 && str[p]-'0'>8)) return INT_MIN;
            res = res*10 + flag*v;
            ++p;
        }
        if(res) return res;
        return 0;
    }
};
```



```python
# python3
```



#### [68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/) [EASY]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root == p || root == q) return root;
        TreeNode* l = lowestCommonAncestor(root->left, p, q);
        TreeNode* r = lowestCommonAncestor(root->right, p, q);
        if(l&&r) return root;
        if(l) return l;
        else return r;
    }
};
```



```python
# python3
```



#### [68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/) [EASY]

```c++
// 同上
```

```python
# python3
```

