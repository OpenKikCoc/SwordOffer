

### SwordOffer

SwordOffer Solutions

[toc]



- [SwordOffer](#swordoffer)
  - [03.数组中重复的数字 [EASY]](#03数组中重复的数字-easy)
  - [04.二维数组中的查找 [EASY]](#04二维数组中的查找-easy)
  - [05.替换空格 [EASY]](#05替换空格-easy)
  - [06.从尾到头打印链表 [EASY]](#06从尾到头打印链表-easy)
  - [07. 重建二叉树 [MID]](#07-重建二叉树-mid)
  - [09. 用两个栈实现队列 [EASY]](#09-用两个栈实现队列-easy)
  - [10- I. 斐波那契数列 [EASY]](#10--i-斐波那契数列-easy)
  - [10- II. 青蛙跳台阶问题 [EASY]](#10--ii-青蛙跳台阶问题-easy)
  - [11. 旋转数组的最小数字 [EASY]](#11-旋转数组的最小数字-easy)
  - [12. 矩阵中的路径 [MID]](#12-矩阵中的路径-mid)
  - [13. 机器人的运动范围 [MID]](#13-机器人的运动范围-mid)
  - [14- I. 剪绳子 [MID]](#14--i-剪绳子-mid)
  - [14- II. 剪绳子 II [MID]](#14--ii-剪绳子-ii-mid)
  - [15. 二进制中1的个数 [EASY]](#15-二进制中1的个数-easy)
  - [16. 数值的整数次方 [MID]](#16-数值的整数次方-mid)
  - [17. 打印从1到最大的n位数 [EASY]](#17-打印从1到最大的n位数-easy)
  - [18. 删除链表的节点 [EASY]](#18-删除链表的节点-easy)
  - [19. 正则表达式匹配 [HARD]](#19-正则表达式匹配-hard)
  - [20. 表示数值的字符串 [MID]](#20-表示数值的字符串-mid)
  - [21. 调整数组顺序使奇数位于偶数前面 [EASY]](#21-调整数组顺序使奇数位于偶数前面-easy)
  - [22. 链表中倒数第k个节点 [EASY]](#22-链表中倒数第k个节点-easy)
  - [24. 反转链表 [EASY]](#24-反转链表-easy)
  - [25. 合并两个排序的链表 [EASY]](#25-合并两个排序的链表-easy)
  - [26. 树的子结构 [MID]](#26-树的子结构-mid)
  - [27. 二叉树的镜像 [EASY]](#27-二叉树的镜像-easy)
  - [28. 对称的二叉树 [EASY]](#28-对称的二叉树-easy)
  - [29. 顺时针打印矩阵 [EASY]](#29-顺时针打印矩阵-easy)
  - [30. 包含min函数的栈 [EASY]](#30-包含min函数的栈-easy)
  - [31. 栈的压入、弹出序列 [MID]](#31-栈的压入弹出序列-mid)
  - [32 - I. 从上到下打印二叉树 [MID]](#32---i-从上到下打印二叉树-mid)
  - [32 - II. 从上到下打印二叉树 II [EASY]](#32---ii-从上到下打印二叉树-ii-easy)
  - [32 - III. 从上到下打印二叉树 III [MID]](#32---iii-从上到下打印二叉树-iii-mid)
  - [33. 二叉搜索树的后序遍历序列 [MID]](#33-二叉搜索树的后序遍历序列-mid)
  - [34. 二叉树中和为某一值的路径 [MID]](#34-二叉树中和为某一值的路径-mid)
  - [35. 复杂链表的复制 [MID]](#35-复杂链表的复制-mid)
  - [36. 二叉搜索树与双向链表 [MID]](#36-二叉搜索树与双向链表-mid)
  - [37. 序列化二叉树 [HARD]](#37-序列化二叉树-hard)
  - [38. 字符串的排列 [MID]](#38-字符串的排列-mid)
  - [39. 数组中出现次数超过一半的数字 [EASY]](#39-数组中出现次数超过一半的数字-easy)
  - [40. 最小的k个数 [EASY]](#40-最小的k个数-easy)
  - [41. 数据流中的中位数 [HARD]](#41-数据流中的中位数-hard)
  - [42. 连续子数组的最大和 [EASY]](#42-连续子数组的最大和-easy)
  - [43. 1～n整数中1出现的次数 [MID]](#43-1n整数中1出现的次数-mid)
  - [44. 数字序列中某一位的数字 [MID]](#44-数字序列中某一位的数字-mid)
  - [45. 把数组排成最小的数 [MID]](#45-把数组排成最小的数-mid)
  - [46. 把数字翻译成字符串 [MID]](#46-把数字翻译成字符串-mid)
  - [47. 礼物的最大价值 [MID]](#47-礼物的最大价值-mid)
  - [48. 最长不含重复字符的子字符串 [MID]](#48-最长不含重复字符的子字符串-mid)
  - [49. 丑数 [MID]](#49-丑数-mid)
  - [50. 第一个只出现一次的字符 [EASY]](#50-第一个只出现一次的字符-easy)
  - [51. 数组中的逆序对 [HARD]](#51-数组中的逆序对-hard)
  - [52. 两个链表的第一个公共节点 [EASY]](#52-两个链表的第一个公共节点-easy)
  - [53 - I. 在排序数组中查找数字 I [EASY]](#53---i-在排序数组中查找数字-i-easy)
  - [53 - II. 0～n-1中缺失的数字 [EASY]](#53---ii-0n-1中缺失的数字-easy)
  - [54. 二叉搜索树的第k大节点 [EASY]](#54-二叉搜索树的第k大节点-easy)
  - [55 - I. 二叉树的深度 [EASY]](#55---i-二叉树的深度-easy)
  - [55 - II. 平衡二叉树 [EASY]](#55---ii-平衡二叉树-easy)
  - [56 - II. 数组中数字出现的次数 II  [MID]](#56---ii-数组中数字出现的次数-ii-mid)
  - [57. 和为s的两个数字 [EASY]](#57-和为s的两个数字-easy)
  - [57 - II. 和为s的连续正数序列 [EASY]](#57---ii-和为s的连续正数序列-easy)
  - [58 - I. 翻转单词顺序 [EASY]](#58---i-翻转单词顺序-easy)
  - [58 - II. 左旋转字符串 [EASY]](#58---ii-左旋转字符串-easy)
  - [59 - I. 滑动窗口的最大值 [EASY]](#59---i-滑动窗口的最大值-easy)
  - [59 - II. 队列的最大值 [MID]](#59---ii-队列的最大值-mid)
  - [60. n个骰子的点数 [EASY]](#60-n个骰子的点数-easy)
  - [61. 扑克牌中的顺子 [EASY]](#61-扑克牌中的顺子-easy)
  - [62. 圆圈中最后剩下的数字 [EASY]](#62-圆圈中最后剩下的数字-easy)
  - [63. 股票的最大利润 [MID]](#63-股票的最大利润-mid)
  - [64. 求1+2+…+n [MID]](#64-求12n-mid)
  - [65. 不用加减乘除做加法 [EASY]](#65-不用加减乘除做加法-easy)
  - [66. 构建乘积数组 [EASY]](#66-构建乘积数组-easy)
  - [67. 把字符串转换成整数 [MID]](#67-把字符串转换成整数-mid)
  - [68 - I. 二叉搜索树的最近公共祖先 [EASY]](#68---i-二叉搜索树的最近公共祖先-easy)
  - [68 - II. 二叉树的最近公共祖先 [EASY]](#68---ii-二叉树的最近公共祖先-easy)

#### [03.数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/) [EASY]

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        unordered_map<int, bool> m;
        int len = nums.size();
        for(int i = 0; i < len; ++i) {
            if(m[nums[i]] == true) return nums[i];
            else {
                m[nums[i]] = true;
            }
        }
        return -1;
    }
// ========= another solution
    int findRepeatNumber(vector<int>& nums) {
        int len = nums.size(), tmp;
        for(int i = 0; i < len; ++i) {
            while(nums[i] != i) {
                if(nums[i] == nums[nums[i]]) return nums[i];
                tmp = nums[i];
                nums[i] = nums[tmp];
                nums[tmp] = tmp;
            }
        }
        return -1;
    }
// =========
};
```



```python
# python3
# 用集合判断 nums[i] 是否存在于集合中，如果存在，则返回该值。但需要用到额外空间，时间复杂度和空间复杂度都是O(N)
class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        my_set=set()
        for c in nums:
            if c in my_set:
                return c
            else:
                my_set.add(c)

#把集合换成哈希表也可以
class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        dict={}
        for i in nums:
           if i not in dic:
               dic[i] = 0
           else:
               return i

# ========= another solution 一个萝卜一个坑
class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        i=0
        while i<len(nums):
            if nums[i]==i:
                i+=1
                continue
            if nums[nums[i]]==nums[i]:return nums[i]
            else:
                nums[nums[i]],nums[i]=nums[i],nums[nums[i]]
        return -1
        
```



#### [04.二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/) [EASY]

```c++
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        if(!m) return false;
        int n = matrix[0].size();
        int u = 0, r = n-1;
        while(u<m&&r>=0) {
            if(matrix[u][r] > target) --r;
            else if (matrix[u][r] < target) ++u;
            else return true;
        }
        return false;
    }
};
```



```python
# python3
class Solution:
    def findNumberIn2DArray(self,matrix:List[List[int]],target:int)->bool:
        rows=len(matrix)
        if rows==0:return False
        cols=len(matrix[0])
        if cols==0:return False

        #从右上角开始查找
        i,j=0,cols-1

        while i<rows and j>=0:
            if matrix[i][j]<target:i+=1
            elif matrix[i][j]>target:j-=1
            else:return True
        return False
```



#### [05.替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/) [EASY]

```c++
class Solution {
public:
    string replaceSpace(string s) {
        int len = s.size();
        string res;
        for(int i = 0; i < len; ++i) {
            if (s[i] == ' ') {
                res+= "%20";
            } else res.push_back(s[i]);
        }
        return res;
    }
};
```



```python
# python3
class Solution:
    def replaceSpace(self,s:str)->str:
        res=[]
        for c in s:
            if c=='':res.append("%20")
            else:res.append(c)
        return ''.join(res)
                    
# ========= another solution, 用python的内置函数（在面试中不推荐使用）           
class Solution:
    def replaceSpace(self, s: str) -> str:
        s = s.replace(' ','%20')
        return s

#创建一个新的字符串，对字符串进行遍历；该方法不如法一用列表好，因为字符串为不可变类型，每加一个字符就会变成新的字符串，太消耗内存了。     
class Solution:
    def replaceSpace(self, s: str) -> str:
        res = ''
        for i in s:
            if i == ' ':
                res += '%20'
            else:
                res += i
        return res
```



#### [06.从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/) [EASY]

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        vector<int> res;
        while(head != nullptr) {
            res.push_back(head->val);
            head = head->next;
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```



```python
# python3
#堆栈法
class Solution:
    def reversePrint(self, head: ListNode) -> List[int]:
        stack = []
        while head: # push
            stack.append(head.val)
            head = head.next
        res = []
        while stack: # pop
            res.append(stack.pop())
        return res

#========= 反转
class Solution:
    def reversePrint(self, head: ListNode) -> List[int]:
        res = []
        while head:
            res.append(head.val)
            head = head.next
        return res[::-1]  # 或者 reverse(res)


#========= 递归
class Solution:
    def reversePrint(self, head: ListNode) -> List[int]:
        if not head: return []
        return self.reversePrint(head.next) + [head.val]


```



#### [07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/) [MID]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* helper(unordered_map<int, int>& h, vector<int>& pre, int s0, int e0, int s1) {
        if(s0 > e0) return nullptr;
        // 父节点 父节点在中序序列的idx
        int mid = pre[s1], idx = h[mid], leftLen = idx-s0;
        TreeNode* node = new TreeNode(mid);
        node->left = helper(h, pre, s0, idx-1, s1+1);
        node->right = helper(h, pre, idx+1, e0, s1+1+leftLen);
        return node;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        unordered_map<int, int> hash;
        for(int i = 0; i < n; ++i) hash[inorder[i]] = i;
        return helper(hash, preorder, 0, n-1, 0);
    }
};
```



```python
# python3
class Solution:
    # def __init__(self):
    #     self.preorder=None
    #     self.reverses=None
    
    def buildTree(self,preorder:List[int],inorder:List[int])->TreeNode:
        # pre_size=len(preorder)
        # in_size=len(inorder)
        # if pre_size!=in_size:
        #     return None

        self.preorder=preorder
        self.reverses=dict()
        # 以空间换时间，否则，找根结点在中序遍历中的位置需要遍历
        for i in range(in_size):
            self.reverses[inorder[i]]=i
        
        return self.recur(0,pre_size-1,0,in_size-1)
    
    def recur(self,pre_left,pre_right,in_left,in_right):
        if pre_left>pre_right or in_left>in_right:
            return None
        
        pivot=self.preorder[pre_left]
        root=TreeNode(pivot)

        pivot_index=self.reverses[pivot]
        root.left=self.recur(pre_left + 1,pivot_index - in_left + pre_left,in_left,pivot_index - 1)
        root.right=self.recur(pivot_index - in_left + pre_left + 1, pre_right,pivot_index + 1, in_right)
        return root
```



#### [09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/) [EASY]

```c++
class CQueue {
    stack<int> in, out;
public:
    CQueue() {
    }
    
    void appendTail(int value) {
        in.push(value);
    }
    
    int deleteHead() {
        if(out.size()) {
            int res = out.top();
            out.pop();
            return res;
        } else if(in.size()) {
            while(in.size()>1) {
                int v = in.top();
                in.pop();
                out.push(v);
            }
            int res = in.top();
            in.pop();
            return res;
        } else return -1;
    }
};

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue* obj = new CQueue();
 * obj->appendTail(value);
 * int param_2 = obj->deleteHead();
 */
```



```python
# python3
class CQueue:

    def __init__(self):
        self.A,self.B=[],[]

    def appendTail(self, value: int) -> None:
        self.A.append(value)

    def deleteHead(self) -> int:
        if self.B:
            return self.B.pop()
        if not self.A:
            return -1
        while self.A:
            self.B.append(self.A.pop())
        return self.B.pop()
```



#### [10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/) [EASY]

```c++
class Solution {
public:
    int mod = 1e9+7;
    int fib(int n) {
        if(n <= 1) return n;
        int a = 0, b = 1, tmp;
        for(int i = 2; i <= n; ++i) {
            tmp = a;
            a = b%mod;
            b = (tmp + b)%mod;
        }
        return b;
    }
};
```



```python
# python3
class Solution:
    def fib(self, n: int) -> int:
        a,b=0,1
        for _ in range(0,n):
            a,b=b,a+b
        return a%1000000007
```



#### [10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/) [EASY]

```c++
// 同上
```



```python
# python3
class Solution:
    def numWays(self, n: int) -> int:
        a, b = 1, 1
        for _ in range(n):
            a, b = b, a + b
        return a % 1000000007
```



#### [11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/) [EASY]

```c++
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int n = numbers.size();
        int l = 0, r = n-1;
        while(l <= r) {
            while(l <= r && numbers[l] == numbers[r]) --r;
            if(l > r || numbers[l] < numbers[r]) break;
            int mid = l + (r-l)/2;
            if(numbers[mid] >= numbers[l]) l = mid+1;	// must mid > r
            else r = mid;
        }
        return numbers[l];
    }
};
```



```python
# python3
class Solution:
    def minArray(self,numbers:List[int])->int:
        i,j=0,len(numbers)-1
        while i<j:
            m=(i+j)//2
            if numbers[m]>numbers[j]:i=m+1
            elif numbers[m]<numbers[j]:j=m
            else:j-=1
        return numbers[i]
```



#### [12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/) [MID]

```c++
class Solution {
public:
    int m, n;
    int dx[4] = {0, -1, 1, 0}, dy[4] = {-1, 0, 0, 1};
    bool dfs(vector<vector<char>>& b, vector<vector<bool>>& vis, string& w, int x, int y, int p) {
        if(b[x][y] != w[p]) return false;
        if(p == w.size()-1) return true;
        vis[x][y] = true;
        for(int i = 0; i < 4; ++i) {
            int nx = x + dx[i], ny = y + dy[i];
            if(nx >= 0 && nx < m && ny >= 0 && ny < n) if(!vis[nx][ny]){
                if(dfs(b, vis, w, nx, ny, p+1)) return true;
            }
        }
        vis[x][y] = false;
        return false;
    }
    bool exist(vector<vector<char>>& board, string word) {
        m = board.size(), n = board[0].size();
        vector<vector<bool>> vis(m, vector<bool>(n));
        for(int i = 0; i < m; ++i)
            for(int j = 0; j < n; ++j)
                if(dfs(board, vis, word, i, j, 0)) return true;
        return false;
    }
};
```



```python
# python3
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        # 使用深度优先搜索
        if not board:   # 边界条件
            return False
        for i in range(len(board)):
            for j in range(len(board[0])):
                if self.dfs(board, i, j, word):
                    return True
        return False

    def dfs(self, board, i, j, word):
        if len(word) == 0: # 如果单词已经检查完毕
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or word[0] != board[i][j]:  # 如果路径出界或者矩阵中的值不是word的首字母，返回False
            return False
        tmp = board[i][j]  # 如果找到了第一个字母，检查剩余的部分
        board[i][j] = '0'
        res = self.dfs(board,i+1,j,word[1:]) or self.dfs(board,i-1,j,word[1:]) or self.dfs(board,i,j+1,word[1:]) or self.dfs(board, i, j-1, word[1:]) # 上下左右四个方向搜索

        board[i][j] = tmp
        return res
      
#========= 
class Solution:
    def exist(self,board:List[List[str]],word:str)->bool:
        def dfs(i,j,k):
            if not 0<=i<len(board) or not 0<=j<len(board[0]) or board[i][j]!=word[k]:
                return False
            if k==len(word)-1:return True
            tmp,board[i][j]=board[i][j],'0'
            res=dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)
            board[i][j]=tmp
            return res
        
        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(i,j,0):
                    return True
        return False
```



#### [13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/) [MID]

```c++
class Solution {
public:
    int res = 0;
    int dx[4] = {-1, 0, 0, 1}, dy[4] = {0, -1, 1, 0};
    void dfs(int x, int y, vector<vector<bool>>& vis, int m, int n, int k) {
        if(!check(x, y, k)) return;
        res++;
        for(int i = 0; i < 4; ++i) {
            int nx = x + dx[i], ny = y + dy[i];
            if(nx < 0 || nx >= m || ny < 0 || ny >= n || vis[nx][ny]) continue;
            vis[nx][ny] = true;
            dfs(nx, ny, vis, m, n, k);
        }
        return;
    }
    bool check(int x, int y, int k) {
        int cnt = 0;
        while(x) {
            cnt+= x%10;
            x/=10;
        }
        while(y) {
            cnt += y%10;
            y/=10;
        }
        return cnt <= k;
    }
    int movingCount(int m, int n, int k) {
        vector<vector<bool>> vis(m, vector<bool>(n));
        res = 0;
        vis[0][0] = true;
        dfs(0, 0, vis, m, n, k);
        return res;
    }
};
```



```python
# python3
#========= DFS
class Solution:
    def movingCount(self,m:int,n:int,k:int)->int:
        def dfs(i,j,si,sj):
            if i>=m or j>=n or k<si+sj or (i,j) in visited:
                return 0
            visited.add((i,j))
            return 1+dfs(i+1,j,si+1 if (i+1)%10 else si-8,sj)+dfs(i,j+1,si, sj+1 if (sj+1)%10 else sj-8)
        
        visited=set()
        return dfs(0,0,0,0)

#========= BFS
class Solution:
    def movingCount(self, m: int, n: int, k: int) -> int:
        queue, visited,  = [(0, 0, 0, 0)], set()
        while queue:
            i, j, si, sj = queue.pop(0)
            if i >= m or j >= n or k < si + sj or (i, j) in visited: continue
            visited.add((i,j))
            queue.append((i + 1, j, si + 1 if (i + 1) % 10 else si - 8, sj))
            queue.append((i, j + 1, si, sj + 1 if (j + 1) % 10 else sj - 8))
        return len(visited)
```



#### [14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/) [MID]

```c++
class Solution {
public:
    int cuttingRope(int n) {
        if(n<=3) return n-1;
        int res = 1;
        if(n%3 == 1) {
            res *= 4;
            n -= 4;
        }
        while(n >= 3) {
            res *= 3;
            n -= 3;
        }
        if(n == 2) res *= 2;
        return res;
    }
};
```



```python
# python3
class Solution:
    def cuttingRope(self, n: int) -> int:
        if n<=3:return n-1
        a,b=n//3,n%3
        if b==0:return int(math.pow(3,a))
        if b==1:return int(math.pow(3,a-1)*4)
        return int(math.pow(3, a) * 2)
```



#### [14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/) [MID]

```c++
class Solution {
public:
    long long mod = 1e9+7;
    int cuttingRope(int n) {
        if(n <= 3) return n-1;
        long long res = 1;
        if(n%3 == 1) {
            res *= 4;
            n -= 4;
        }
        while(n>=3) {
            res *= 3;
            res %= mod;
            n -= 3;
        }
        if (n == 2) res *= 2;
        return res % mod;    
    }
};
```



```python
# python3

```



#### [15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/) [EASY]

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int res = 0;
        while(n) {
            n = n&(n-1);
            ++res;
        }
        return res;
    }
};
```



```python
# python3
class Solution:
    def hammingWeight(self, n: int) -> int:
        res=0
        while n:
            res+=n&1
            n>>=1
        return res
```



#### [16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/) [MID]

```c++
class Solution {
public:
    double myPow(double x, int n) {
      	// case
        if(x == 1) return 1;
        else if(x == -1) return n&1?-1:1;
        if(n == INT_MIN) return 0;
        int N = n;
        if (n < 0) {
            N = -N;
            x = 1.0/x;
        }
        double res = 1;
        while(N) {
            if (N&1) res *= x;
            x *= x;
            N >>= 1;
        }
        return res;
    }
};
```



```python
# python3

```



#### [17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/) [EASY]

```c++
class Solution {
public:
    vector<int> printNumbers(int n) {
        int tot = 1;
        while(n--) tot *= 10;
        vector<int> res;
        for(int i = 1; i < tot; ++i) {
            res.push_back(i);
        }
        return res;
    }
};
```



```python
# python3
class Solution:
    def printNumbers(self, n: int) -> List[int]:
        return [i for i in range(1,10**n)]
```



#### [18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/) [EASY]

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* pre = dummy, *now = dummy->next;
        while(now != nullptr && now->val != val) {
            pre = pre->next;
            now = now->next;
        }
        if(now == nullptr) return dummy->next;
        pre->next = now->next;
        return dummy->next;
    }
};
```



```python
# python3
class Solution:
    def deleteNode(self,head:ListNode,val:int)->ListNode:
        if head.val==val:
            return head.next
        pre, cur=head,head.next
        while cur and cur.val!=val:
            pre,cur=cur,cur.next
        if cur:
            pre.next=cur.next
        return head
```



#### [19. 正则表达式匹配](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/) [HARD]

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size();
        vector<vector<bool>> dp(m+1, vector<bool>(n+1));
        dp[0][0] = true;
        for(int i = 2; i <= n; ++i)
            if(p[i-1] == '*') dp[0][i] = dp[0][i-2];
        for(int i = 1; i <= m; ++i) {
            for(int j = 1; j <= n; ++j) {
                if(s[i-1] == p[j-1] || p[j-1] == '.') {
                    // s[i-1] p[j-1] 可以匹配
                    dp[i][j] = dp[i-1][j-1];
                } else if (p[j-1] == '*') {
                    // 此时显然s[i-1] p[j-1] 不可以匹配 考虑使用p[j-2]位置
                    // if 不能匹配->不使用p[j-2]与p[j-1]组成的模式串
                    // else 能匹配->使用p[j-2]与p[j-1]组成的模式串1或多次
                    if(p[j-2] != '.' && p[j-2] != s[i-1]) dp[i][j] = dp[i][j-2];
                    else dp[i][j] = dp[i][j-2] || dp[i-1][j];
                }
            }
        }
        return dp[m][n];
    }
};
```



```python
# python3
```



#### [20. 表示数值的字符串](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/) [MID]

```c++
class Solution {
public:
    bool isNumber(string s) {
        int len = s.size();
      	// d1:整数部分 d2:小数部分 d3:幂次部分
        int p = 0, d1 = 0, dot = 0, d2 = 0, e = 0, d3 = 0;
        while(p<len && s[p] == ' ') ++p;
        if(s[p] == '-' || s[p] == '+') ++p;
        while(p < len && s[p] >= '0' && s[p] <= '9') d1 = ++p;
        if(p < len && s[p] == '.') {
            dot = ++p;
            while(p<len && s[p] >= '0' && s[p] <= '9') d2 = ++p;
        }
        if(dot && !d1 && !d2) return false;
        if(p<len && (d1||d2) && s[p]=='e') e = ++p;
        if(p<len && e && (s[p]=='+'|s[p]=='-')) ++p;
        while(p<len && s[p] >= '0' && s[p] <= '9') d3 = ++p;
        if(e && (!(d1||d2) || !d3)) return false;
        while(p<len && s[p] == ' ') ++p;
        if(!d1 && !d2) return false;
        return p==len;
    }
};
```



```python
# python3
```



#### [21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/) [EASY]

```c++
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        int len = nums.size();
        if(len <= 1) return nums;
        int l = 0, r = len-1;
        while(l < r) {
            while(l < r && nums[l]&1) ++l;
            if(l >= r) break;
            while(l < r && (nums[r]%2 == 0)) --r;
            // attention 不能写nums[r] & 1 == 0
            if(l >= r) break;
            swap(nums[l++], nums[r--]);
        }
        return nums;
    }
};
```



```python
# python3
#双指针法
class Solution:
    def exchange(self,nums:List[int])->List[int]:
        i,j=0,len(nums)-1
        while i<j:
            while i<j and nums[i]%2==1:
                i+=1
            while i<j and nums[j]%2==0:
                j-=1
            nums[i],nums[j]=nums[j],nums[i]
        return nums
```



#### [22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/) [EASY]

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* slow = dummy, *fast = dummy;
        while(k--) {
            fast = fast->next;
        }
        while(fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next;
        }
        return slow->next;
    }
  	// another solution
    ListNode* getKthFromEnd(ListNode* head, int k) {
      	ListNode* slow = head, *fast = head;
      	while(k--) fast = fast->next;
      	while(fast) {
          	slow = slow->next;
          	fast = fast->next;
        }
      	return slow;
    }
};
```



```python
# python3
class Solution:
    def getKthFromEnd(self,head:ListNode,k:int)->ListNode:
        fast,slow=head,head
        for _ in range(k):
            fast=fast.next
        while fast!=None:
            fast,slow=fast.next,slow.next
        return slow
```



#### [24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/) [EASY]

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *cur = head, *pre = nullptr, *next;
        while(cur) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    // 递归
    ListNode* reverseList(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode* ret = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return ret;
    }
};
```



```python
# python3
#========= 迭代
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self,head:ListNode)->ListNode:
        cur,pre,p=head,None,None
        while cur:
            p=cur.next
            cur.next=pre
            pre=cur
            cur=p
        return pre


#========= 递归
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        cur = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return cur
     
 #=========借助列表
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        outList = []
        phead=head
        while phead != None:
            outList.append(phead.val)
            phead = phead.next
            
        outList.reverse()
        print(outList)
        return outList

```



#### [25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/) [EASY]

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(-1);
        ListNode* pre = dummy;
        while(l1 && l2) {
            if(l1->val <= l2->val) {
                pre->next = l1;
                l1 = l1->next;
            } else {
                pre->next = l2;
                l2 = l2->next;
            }
            pre = pre->next;
        }
        if(l1) pre->next = l1;
        else pre->next = l2;
    }
/*
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == nullptr) return l2;
        else if (l2 == nullptr) return l1;
        else if (l1->val < l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        } else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
*/
};
```



```python
# python3
#伪头节点dum节点
class Solution:
    def mergeTwoLists(self,l1:ListNode,l2:ListNode)->ListNode:
        cur=dum=ListNode(0)
        while l1 and l2:
            if l1.val<l2.val:
                cur.next,l1=l1,l1.next
            else:
                cur.next,l2=l2,l2.next
            cur=cur.next
        cur.next=l1 if l1 else l2
        return dum.next
```



#### [26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/) [MID]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool helper(TreeNode* a, TreeNode* b) {
        if(!b) return true;
        if(!a) return false;
        return a->val == b->val && helper(a->left, b->left) && helper(a->right, b->right);
    }
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if(!A || !B) return false;
        return helper(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }
};
```



```python
# python3

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def isSubStructure(self, A: TreeNode, B: TreeNode) -> bool:
        def dfs(A, B):
            if not B: return True
            if not A or A.val != B.val: return False
            return dfs(A.left, B.left) and dfs(A.right, B.right)

        return bool(A and B) and (dfs(A, B) or self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B))
      
      
      
###两个函数分开写     
class Solution:
    def isSubStructure(self, A: TreeNode, B: TreeNode) -> bool:
        if A==None or B==None:
            return False
        return self.dfs(A,B) or self.isSubStructure(A.left,B) or self.isSubStructure(A.right,B)

    def dfs(self,A: TreeNode, B: TreeNode) -> bool:
        if B==None:return True
        if A==None:return False
        return A.val==B.val and self.dfs(A.left,B.left) and self.dfs(A.right,B.right)
```



#### [27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/) [EASY]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(!root) return nullptr;
        TreeNode *l = mirrorTree(root->right), *r = mirrorTree(root->left);
        root->left = l, root->right = r;
        return root;
    }
};
```



```python
# python3
#递归
class Solution:
    def mirrorTree(self,root:TreeNode)->TreeNode:
        if not root:
            return None
        root.left,root.right=self.mirrorTree(root.right), self.mirrorTree(root.left)
        return root

#不省略tmp的写法
class Solution:
    def mirrorTree(self, root: TreeNode) -> TreeNode:
        if not root: 
            return None
        tmp = root.left
        root.left = self.mirrorTree(root.right)
        root.right = self.mirrorTree(tmp)
        return root


```



#### [28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/) [EASY]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool helper(TreeNode* l, TreeNode* r) {
        if(!l && !r) return true;
        else if(!l || !r) return false;
        return l->val == r->val && helper(l->left, r->right) && helper(l->right, r->left);
    }
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return helper(root->left, root->right);
    }
};
```



```python
# python3
#两个函数分开写
class Solution:
    def isSymmetric(self,root:TreeNode)->bool:
        res=True
        if root:
            res=self.recur(root.left,root.right)
            # res=self.recur(root.left,root.right)
        return res

    def recur(self,L,R):
        if not L and not R:return True
        if not L or not R or L.val!=R.val:return False
        return self.recur(L.left,R.right) and self.recur(L.right,R.left)

#递归函数写在主函数里
class Solution:
    def isSymmetric(self,root:TreeNode)->bool:
        def recur(L,R):
            if not L and not R:
                return True
            if not L or not R or L.val!=R.val:
                return False
            return recur(L.left,R.right) and recur(L.right,R.left)
        
        return recur(root.left,root.right) if root else True
```



#### [29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/) [EASY]

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        int m = matrix.size();
        if(!m) return res;
        int n = matrix[0].size();
        int u = 0, d = m-1, l = 0, r = n-1;
        while(u<=d && l <=r) {
            for(int i = l; i <= r; ++i) res.push_back(matrix[u][i]);
            if(++u > d) break;
            for(int i = u; i <= d; ++i) res.push_back(matrix[i][r]);
            if(--r < l) break;
            for(int i = r; i >= l; --i) res.push_back(matrix[d][i]);
            if(--d < u) break;
            for(int i = d; i >= u; --i) res.push_back(matrix[i][l]);
            if(++l > r) break;
        }
        return res;
    }
};
```



```python
# python3
class Solution:
    def spiralOrder(self,matrix:List[List[int]])->List[int]:
        if not matrix:return []
        L,R,T,B,res=0,len(matrix[0])-1,0,len(matrix)-1,[]
        while True:
            for i in range(L,R+1):
                res.append(matrix[T][i])
            T+=1
            if T>B:break
            for i in range(T,B+1):
                res.append(matrix[i][R])
            R-=1
            if L>R:break
            for i in range(R,L-1,-1):
                res.append(matrix[B][i])
            B-=1
            if T>B:break
            for i in range(B,T-1,-1):
                res.append(matrix[i][L])
            L+=1
            if L>R:break
        return res
```



#### [30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/) [EASY]

```c++
class MinStack {
    stack<int> s, mins;
public:
    /** initialize your data structure here. */
    MinStack() {
    }
    
    void push(int x) {
        if(s.empty() || x <= mins.top()) mins.push(x);
        else mins.push(mins.top());
        s.push(x);
    }
    
    void pop() {
        s.pop();
        mins.pop();
    }
    
    int top() {
        return s.top();
    }
    
    int min() {
        return mins.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->min();
 */
```



```python
# python3

class MinStack:
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.mini = []
        self.stack = []
    def push(self, x: int) -> None:
        self.stack.append(x)
        if self.mini != []:
            if x<self.mini[-1]:self.mini.append(x)
            else: self.mini.append(self.mini[-1])
        else:
            self.mini.append(x)

    def pop(self) -> None:
        self.mini.pop()
        return(self.stack.pop())

    def top(self) -> int:
        return(self.stack[-1])


    def min(self) -> int:
        return(self.mini[-1])
```



#### [31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/) [MID]

```c++
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        int m = pushed.size(), n = popped.size();
        if(m != n) return false;
        int p = 0;
        stack<int> s;
        for(int i = 0; i < n; ++i) {
            s.push(pushed[i]);
            while(!s.empty() && s.top() == popped[p]) {
                s.pop();
                ++p;
            }
        }
        return p == n;
    }
};
```



```python
# python3
class Solution:
    def validateStackSequences(self,pushed:List[int],popped:List[int])->bool:
        res,i=[],0
        for num in pushed:
            res.append(num)
            while res and res[-1]==popped[i]:
              #pop()默认弹出最后一个元素
                res.pop()
                i+=1
        return not res
```



#### [32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/) [MID]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        vector<int> res;
        if(!root) return res;
        queue<TreeNode*> q;
        q.push(root);
        TreeNode* v;
        while(!q.empty()) {
            v = q.front();
            q.pop();
            res.push_back(v->val);
            if(v->left) q.push(v->left);
            if(v->right) q.push(v->right);
        }
        return res;
    }
};
```



```python
# python3
#deque是双端队列，popleft的效率更高
class Solution:
    def levelOrder(self,root:TreeNode)->List[int]:
        if not root:return []
        res,queue=[],collections.deque()
        queue.append(root)
        while queue:
           #node=queue.pop(0)
            node=queue.popleft()
            res.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        return res
```



#### [32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/) [EASY]

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(!root) return res;
        queue<TreeNode*> q;
        q.push(root);
        TreeNode* v;
        while(!q.empty()) {
            int tot = q.size();
            vector<int> tmp;
            for(int i = 0; i < tot; ++i) {
                v = q.front();
                tmp.push_back(v->val);
                q.pop();
                if(v->left) q.push(v->left);
                if(v->right) q.push(v->right);
            }
            res.push_back(tmp);
        }
        return res;
    }
};
```



```python
# python3
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:return []
        res,queue=[],collections.deque()
        queue.append(root)
        while queue:
            tmp=[]
            for _ in range(len(queue)):
                node=queue.popleft()
                tmp.append(node.val)
                if node.left:queue.append(node.left)
                if node.right:queue.append(node.right)
            res.append(tmp)
        return res
```



#### [32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/) [MID]

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(!root) return res;
        stack<TreeNode*> sl, sr;
        sl.push(root);
        TreeNode* v;
        while(!sl.empty() || !sr.empty()) {
            vector<int> tmp;
            if(sl.empty()) {
                int tot = sr.size();
                for(int i = 0; i < tot; ++i) {
                    v = sr.top();
                    sr.pop();
                    tmp.push_back(v->val);
                    if(v->right) sl.push(v->right);
                    if(v->left) sl.push(v->left);
                }
            } else {
                int tot = sl.size();
                for(int i = 0; i < tot; ++i) {
                    v = sl.top();
                    sl.pop();
                    tmp.push_back(v->val);
                    if(v->left) sr.push(v->left);
                    if(v->right) sr.push(v->right);
                }
            }
            res.push_back(tmp);
        }
        return res;
    }
};
```



```python
# python3
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

###用两个双端队列
#值得注意的是，记录路径时若直接执行 res.append(tmp) ，则是将tmp对象加入了res；后续tmp改变时,res中的tmp对象也会随之改变。

正确做法：res.append(list(path)) ，相当于复制了一个 path 并加入到 res 。

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:return []
        res,queue=[],collections.deque()
        queue.append(root)
        while queue:
            tmp=collections.deque()
            for _ in range(len(queue)):
                node=queue.popleft()
                if len(res)%2:tmp.appendleft(node.val)
                else:tmp.append(node.val)
                if node.left:queue.append(node.left)
                if node.right:queue.append(node.right)
            res.append(list(tmp))
        return res
      
###用BFS模版
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: return []
        res = []
        q = collections.deque()  # BFS模板，需要用队列实现
        q.append(root)
        while q:
            tmp = []
            for _ in range(len(q)): # 模板操作
                node = q.popleft()
                tmp.append(node.val)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            if len(res) % 2 == 0:  # 如果当前的res的长度是偶数，说明本次tmp中存储的是偶数层(设根为 0 层)
                res.append(tmp)
            else:
                res.append(tmp[::-1])  # 否则将tmp翻转再加入结果集
        return res


```



#### [33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/) [MID]

[单调栈解法](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/dan-diao-di-zeng-zhan-by-shi-huo-de-xia-tian/)

```c++
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        int n = postorder.size();
        if(n<=1) return true;
        stack<int> s;
        int pre = INT_MAX;
        for(int i = n-1; i >= 0; --i) {
            if(postorder[i] > pre) {
                return false;
            }
            while(!s.empty() && postorder[i] < s.top()) {
                pre = s.top();
                s.pop();
            }
            s.push(postorder[i]);
        }
        return true;
    }
};
```



```python
# python3
#易懂的代码
class Solution:
    def verifyPostorder(self, postorder: List[int]) -> bool:
        if postorder is None or len(postorder)==0:
            return True
        n=len(postorder)

        root=postorder[-1]
        for i in range(n):
            if postorder[i]>root:
                break
        
        for j in range(i,n-1):
            if postorder[j]<root:
                return False
        left=True
        if i>=0:
            left=self.verifyPostorder(postorder[:i])
        right=True
        if i<=n-1:
            right=self.verifyPostorder(postorder[i:-1])
        return left and right


#简洁的代码
class Solution:
    def verifyPostorder(self, postorder: [int]) -> bool:
        def recur(i,j):
            if i>=j:return True
            p=i
            while postorder[p]<postorder[j]:p+=1
            m=p
            while postorder[p]>postorder[j]:p+=1
            return p==j and recur(i,m-1) and recur(m,j-1)
        
        return recur(0,len(postorder)-1)
```



#### [34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/) [MID]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void helper(TreeNode* root, int target) {
        if(!root) return;
        path.push_back(root->val);
        if(root->val == target && !root->left && !root->right) res.push_back(path);
        helper(root->left, target-root->val);
        helper(root->right, target-root->val);
        path.pop_back(); 
    }
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        helper(root, sum);
        return res;
    }
};
```



```python
# python3
class Solution:
    def pathSum(self,root:TreeNode,sum:int)->List[List[int]]:
        res, path=[],[]
        def dfs(root,tar):
            if not root:return
            path.append(root.val)
            tar-=root.val
            if tar==0 and not root.left and not root.right:
                res.append(list(path))
            dfs(root.left,tar)
            dfs(root.right,tar)
            path.pop()
        
        dfs(root,sum)
        return res
```



#### [35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/) [MID]

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(!head) return head;
        Node* p = head;
        while(p) {
            Node* n = new Node(p->val);
            n->next = p->next;
            n->random = p->random;
            p->next = n;
            p = n->next;
        }
        p = head;
        while(p) {
            if(p->next->random) p->next->random = p->next->random->next;
            p = p->next->next;
        }
        Node* oldp = head, *newp = head->next;
        Node* newl = newp;
        while(oldp) {
            oldp->next = oldp->next->next;
            if(newp->next) newp->next = newp->next->next;
            oldp = oldp->next;
            newp = newp->next;
        }
        return newl;
    }
};
```



```python
# python3
```



#### [36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/) [MID]

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;

    Node() {}

    Node(int _val) {
        val = _val;
        left = NULL;
        right = NULL;
    }

    Node(int _val, Node* _left, Node* _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
public:
    void helper(Node* root, Node*& head, Node*& pre) {
        if(!root) return;
        helper(root->left, head, pre);
        if(!head) {
            head = root;	// 初始化
            pre = root;
        } else {
            pre->right = root;
            root->left = pre;
            pre = root;
        }
        helper(root->right, head, pre);
    }
    Node* treeToDoublyList(Node* root) {
        if(!root) return root;
        Node *head = nullptr,  *pre = nullptr;
        helper(root, head, pre);
        head->left = pre;
        pre->right = head;
        return head;
    }
};
```



```python
# python3
```



#### [37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/) [HARD]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        ostringstream out;
        queue<TreeNode*> q;
        q.push(root);
        TreeNode* tmp;
        while(!q.empty()) {
            tmp = q.front();
            q.pop();
            if(tmp != nullptr) {
                out << tmp->val<<" ";
                q.push(tmp->left);
                q.push(tmp->right);
            } else {
                out << "null ";
            }
        }
        return out.str();
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream in(data);
        string val;
        vector<TreeNode*> vec;
        while(in>>val) {
            if(val == "null") {
                vec.push_back(nullptr);
            } else vec.push_back(new TreeNode(stoi(val)));
        }
        int j = 1;
        for(int i = 0; i < vec.size(); ++i) {
            if(vec[i] == nullptr) continue;
            if(j<vec.size()) vec[i]->left = vec[j++];
            if(j<vec.size()) vec[i]->right = vec[j++];
        }
        return vec[0];
    }
};
```



```python
# python3
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:
    def serialize(self, root):
        if not root:return "[]"
        queue=collections.deque()
        queue.append(root)
        res=[]
        while queue:
            node=queue.popleft()
            if node:
                res.append(str(node.val))
                queue.append(node.left)
                queue.append(node.right)
            else:res.append("null")
        return '['+','.join(res)+']'

    def deserialize(self,data):
        if data=="[]":return
        vals,i=data[1:-1].split(','),1
        root=TreeNode(int(vals[0]))
        queue=collections.deque()
        queue.append(root)
        while queue:
            node=queue.popleft()
            if vals[i]!="null":
                node.left=TreeNode(int(vals[i]))
                queue.append(node.left)
            i+=1
            if vals[i]!="null":
                node.right=TreeNode(int(vals[i]))
                queue.append(node.right)
            i+=1
        return root
```



#### [38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/) [MID]

```c++
class Solution {
public:
    void dfs(vector<string>& res, string s, string& track, vector<bool>& vis) {
        if(track.size() == s.size()) {
            res.push_back(track);
            return;
        }
        for(int i = 0; i < s.size(); ++i) {
            if(vis[i]) continue;
            if(i>0 && vis[i-1] && s[i-1] == s[i]) continue;
            vis[i] = true;
            track.push_back(s[i]);
            dfs(res, s, track, vis);
            track.pop_back();
            vis[i] = false;
        }
    }
    vector<string> permutation(string s) {
        vector<string> res;
        if(s.empty()) return res;
        sort(s.begin(), s.end());
        int n = s.size();
        vector<bool> vis(n, false);
        string track;
        dfs(res, s, track, vis);
        return res;
    }
};
```



```python
# python3
```



#### [39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/) [EASY]

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int n = nums.size();
        int value = nums[0], votes = 1;
        for(int i = 1; i < n; ++i) {
            if(nums[i] == value) ++votes;
            else {
                votes?--votes:(value = nums[i],votes = 1);
                //if(votes) --votes;
                //else value = nums[i], votes = 1;
            }
       }
       return value;
    }
};
```



```python
# python3
class Solution:
    def majorityElement(self,nums:List[int])->int:
        votes=0
        for num in nums:
            if votes==0:
                x=num
            if num==x:
                votes+=1
            else:
                votes-=1
        return x
```



#### [40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/) [EASY]

```c++
class Solution {
public:
    int partition(vector<int>& nums, int l, int r) {
        int pivot = nums[l];	// privot = nums[rand((r-l)%l+l)]
        while(l<r) {
            while(l < r && nums[r] >= pivot) --r;
            nums[l] = nums[r];
            while(l < r && nums[l] <= pivot) ++l;
            nums[r] = nums[l];
        }
        nums[l] = pivot;
        return l;
    }
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        int len = arr.size();
        vector<int> res;
        int l = 0, r = len-1;
        while(l<=r) {
            int index = partition(arr, l, r);
            if(index == k-1) {
                for(int i = 0; i < k; ++i) res.push_back(arr[i]);
                return res;
            } else if(index < k) {
                l = index + 1;
            } else r = index - 1;
        }
        return res;
    }
};
```



```python
# python3
class Solution:
    def partition(self, nums, l, r):
        import random
        i=random.randint(l,r)
        nums[l],nums[i]=nums[i],nums[l]
        pivot = nums[l]
        while l < r:
            while l < r and pivot <= nums[r]:
                r -= 1
            nums[l] = nums[r]
            while l < r and nums[l] <= pivot:
                l += 1
            nums[r] = nums[l]
        nums[l] = pivot
        return l 

    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        if k == 0: return list()
        l, r = 0, len(arr)-1
        idx = self.partition(arr, l, r)
        while idx != k - 1:
            if idx < k-1:
                l = idx+1
                idx = self.partition(arr, l, r)
            if idx > k-1:
                r = idx-1
                idx = self.partition(arr, l, r)
        return arr[:k]
```



#### [41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/) [HARD]

```c++
class MedianFinder {
    priority_queue<int> lo;                              // 大顶堆 都比中位数小
    priority_queue<int, vector<int>, greater<int>> hi;   // 小顶堆
public:
    /** initialize your data structure here. */
    MedianFinder() {
    }
    
    void addNum(int num) {
        lo.push(num);
        hi.push(lo.top());
        lo.pop();
        if(lo.size() < hi.size()) {
            lo.push(hi.top());
            hi.pop();
        }
    }
    
    double findMedian() {
        return lo.size() > hi.size() ? (double)lo.top() : (lo.top() + hi.top())*0.5;
    }
};
```



```python
# python3
```



#### [42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/) [EASY]

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int sum = INT_MIN, res = INT_MIN;
        for(auto v : nums) {
            if(sum <= 0) sum = v;
            else sum += v;
            res = max(res, sum);
        }
        return res;
    }
};
```



```python
# python3
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        maxnum=nums[0]
        for i in range(1,len(nums)):
            if nums[i-1]>0:
                nums[i]+=nums[i-1]
            maxnum=max(maxnum,nums[i])
        return maxnum

```



#### [43. 1～n整数中1出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/) [MID]

```c++
class Solution {
public:
    int countDigitOne(int n) {
        int res = 0;
        long long base = 1;
        while(base <= n) {
            int t = (n/base)%10;
            if(t == 0) res += n/(base*10)*base; // front
            else if(t == 1) res += n/(base*10)*base + n%base + 1;
            else res += (n/(base*10)+1)*base;
            base *= 10;
        }
        return res;
    }
};
```



```python
# python3
```



#### [44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/) [MID]

```c++
class Solution {
public:
    int findNthDigit(int n) {
        if(n < 10) return n;
        int base = 1;
        // 0-9 10-99 100-999
        // 9 90*2 900*3
        while(n > 9*pow(10, base-1)*base){
            n -= 9*pow(10, base-1)*base;
            ++base;
        }
        // pow(10, base-1) 为该位宽的第一个数
        int value = pow(10, base-1)+n/base;
        int mod = n%base;
        if(mod) return (value/(int)pow(10, base-mod))%10;// 当前数的某一位
        return (value-1)%10;    // 上个数的末尾
    }
};
```



```python
# python3
```



#### [45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/) [MID]

```c++
class Solution {
public:
    string minNumber(vector<int>& nums) {
        auto cmp = [](string& sa, string& sb){return sa+sb < sb+sa;};
        vector<string> t;
        for(auto v : nums) t.push_back(to_string(v));
        sort(t.begin(), t.end(), cmp);
        string res;
        for(auto s : t) res += s;
        return res;
    }
};
```



```python
# python3
```



#### [46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/) [MID]

```c++
class Solution {
public:
    int translateNum(int num) {
        string v = to_string(num);
        int n = v.size();
        if(n <= 1) return 1;
        vector<int> dp(n+1);
        dp[1] = 1;dp[0] = 1;
        for(int i = 2; i <= n; ++i) {
            dp[i] = dp[i-1];		// dp[i] 为v[i-1]字符对应的dp值
            if(v[i-2] == '1' && v[i-1] >= '0' && v[i-1] <= '9') {
                dp[i] += dp[i-2];
            }
            else if(v[i-2] == '2' && v[i-1] >= '0' && v[i-1] <= '5') {
                dp[i] += dp[i-2];
            }
        }
        return dp[n];
    }
};
```



```python
# python3
class Solution:
    def translateNum(self, num: int) -> int:
        s=str(num)
        n=len(s)
        dp=[1 for _ in range(n+1)]
        for i in range(2,n+1):
            dp[i]=dp[i-1]
            if s[i-2]=='1':
                dp[i]+=dp[i-2]
            elif s[i-2]=='2' and s[i-1]<'6':
                dp[i]+=dp[i-2]
        return dp[n]
      
 # python3    
class Solution:
    def translateNum(self, num: int) -> int:
        s = str(num)
        a = b = 1
        for i in range(2, len(s) + 1):
            a, b = (a + b if "10" <= s[i - 2:i] <= "25" else a), a
        return a
```



#### [47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/) [MID]

```c++
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> dp(n+1);
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                dp[j] = max(j?dp[j-1]:0, dp[j]) + grid[i][j];
            }
        }
        return dp[n-1];
    }
};
```



```python
# python3
class Solution:
    def maxValue(self,grid:List[List[int]])->int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i==0 and j==0:continue
                if i==0:grid[i][j]+=grid[i][j-1]
                elif j==0:grid[i][j]+=grid[i-1][j]
                else:grid[i][j]+=max(grid[i][j-1],grid[i-1][j])
        return grid[-1][-1]
```



#### [48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/) [MID]

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int> m(300, -1);
        int res = 0, n = s.size(), l = -1;
        for(int i = 0; i < n; ++i) {
            if(m[s[i]] > l) {
                l = m[s[i]];
            }
            res = max(res, i-l);
            m[s[i]] = i;
        }
        return res;
    }
};
```



```python
# python3
###双指针法
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        head,tail=0,0
        if len(s)<2:return len(s)
        res=1

        while tail<len(s)-1:
            tail+=1
            if s[tail] not in s[head:tail]:
                res=max(tail-head+1,res)
            else:
                while s[tail] in s[head:tail]:
                    head+=1
        return res
      
#双指针+hash表优化，hash表记录每一个字符出现的位置的后面一个位置
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        n=len(s)-1
        dic={}
        head,tail,res=0,0,0
        for tail in range(n+1):
            if s[tail] in dic:
                head=max(dic[s[tail]],head)
            dic[s[tail]]=tail+1
            res=max(res,tail-head+1)
        return res
```



#### [49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/) [MID]

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        int two = 0, three = 0, five = 0;
        vector<long long> ugly;
        ugly.push_back(1ll);
        long long v = 1;
        while(--n) {
            v = min(ugly[two]*2, ugly[three]*3);
            v = min(v, ugly[five]*5);
            ugly.push_back(v);
            if(v%2==0) ++two;
            if(v%3==0) ++three;
            if(v%5==0) ++five;
        }
        return v;
    }
};
```



```python
# python3
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        #初始化dp列表
        dp,a,b,c=[1]*n,0,0,0
        for i in range(1,n):
            n2,n3,n5=dp[a]*2,dp[b]*3,dp[c]*5
            dp[i]=min(n2,n3,n5)
            if dp[i]==n2:a+=1
            if dp[i]==n3:b+=1
            if dp[i]==n5:c+=1
        return dp[-1]
```



#### [50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/) [EASY]

```c++
class Solution {
public:
    char firstUniqChar(string s) {
        vector<int> m(30);
        for(auto c : s) ++m[c-'a'];
        for(auto c : s) if(m[c-'a'] == 1) return c;
        return ' ';
    }
};
```



```python
# python3
# 如果dic中不包含key(c),则向dic中添加键值对(c,True);否则就是(c,False)
 class Solution:
    def firstUniqChar(self, s: str) -> str:
        dic={}
        for c in s:
            dic[c]=not c in dic
        for c in s:
            if dic[c]:return c
        return ' '
      
 #另外一种写法：若c已经存在hash表中，则讲它的值置为0；没有出现过就是1     
class Solution:
    def firstUniqChar(self, s: str) -> str:
        dic={}
        for c in s:
            if c in dic:
                dic[c]=0
            else:
                dic[c]=1
        for c in s:
            if dic[c]==1:return c
        return ' '
```



#### [51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/) [HARD]

```c++
class Solution {
public:
    int merge(vector<int>& nums, vector<int>& t, int l, int r) {
        if(l >= r) return 0;
        int mid = l + (r-l)/2;
        int cnt = merge(nums, t, l, mid) + merge(nums, t, mid+1, r);
        int i = l, j = mid+1, p = l;
        while(i <= mid && j <= r) {
            if(nums[i] <= nums[j]) t[p++] = nums[i++];
            else {
                cnt += mid - i + 1;
                t[p++] = nums[j++];
            }
        }
        while(i <= mid) t[p++] = nums[i++];
        while(j <= r) t[p++] = nums[j++];
        copy(t.begin()+l, t.begin()+r+1, nums.begin()+l);
        return cnt;
    }
    int reversePairs(vector<int>& nums) {
        int n = nums.size();
        vector<int> t(n);
        return merge(nums, t, 0, n-1);
    }
};
```



```python
# python3
# 后有序数组中元素出列的时候，计算逆序个数

#from typing import List
class Solution:
    def reversePairs(self, nums: List[int]) -> int:
        n=len(nums)
        return self.mergeSort(nums,0,n-1)
        
    def merge(nums, start, mid, end):
        i, j, temp = start, mid + 1, []
        while i <= mid and j <= end:
            if nums[i] <= nums[j]:
                temp.append(nums[i])
                i += 1
            else:
                self.cnt += mid - i + 1
                temp.append(nums[j])
                j += 1
        while i <= mid:
            temp.append(nums[i])
            i += 1
        while j <= end:
            temp.append(nums[j])
            j += 1
            
        for i in range(len(temp)):
            nums[start + i] = temp[i]
                    

    def mergeSort(nums, start, end):
        if start >= end: return
        mid = (start + end) >> 1
            mergeSort(nums, start, mid)
            mergeSort(nums, mid + 1, end)
            merge(nums, start, mid,  end)
```



#### [52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/) [EASY]

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* l1 = headA, *l2 = headB;
        while(l1 != l2) {
            l1 = l1 ? l1->next:headB;
            l2 = l2 ? l2->next:headA;
        }
        return l1;
    }
};
```



```python
# python3
class Solution:
    def getIntersectionNode(self,headA:ListNode,headB:ListNode)->ListNode:
        node1,node2=headA,headB
        while node1!=node2:
            #被注释掉的写法会超时，正确的写法巧妙的避开了两条链表最后都指向了同一个null节点，代替了不相交的特殊情况。
            #node1 = node1.next if node1.next else headB
            node1=node1.next if node1 else headB
            node2=node2.next if node2 else headA
        return node1
```



#### [53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/) [EASY]

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        if(!n) return 0;
      
        int l = 0, r = n-1, s, t;
        while(l<=r) {
            int mid = l + (r-l)/2;
            if(nums[mid] < target) l = mid+1;
            else r = mid-1;
        }
        if(l >= n || nums[l] != target) s = -1;
        else s = l;
        if(s == -1) return 0;
      
        l = 0, r = n-1;
        while(l<=r) {
            int mid = l + (r-l)/2;
            if(nums[mid] <= target) l = mid+1;
            else r = mid-1;
        }
        if(r < 0 || nums[r] != target) t = -1;
        else t = r;
      	
        return t-s+1;
    }
};
```



```python
# python3
class Solution:
#找到target后，还需要看它左右是否还有相同的数字，所以讲两个指针都指向中间，再往两边扩散
    def search(self,nums:List[int],target:int)->int:
        L,R=0,len(nums)
        while L<R:
            m=(L+R)//2
            if nums[m]==target:
                i=j=m
                while i>=0 and nums[i]==target:
                    i-=1
                while j<R and nums[j]==target:
                    j+=1
                return j-i-1
            elif nums[m]<target:
                L=m+1
            else:R=m
        return 0


```



#### [53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/) [EASY]

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int target = (n+1)*n/2;
        int tot = 0;
        for(auto v : nums) tot += v;
        return target - tot;
    }
  	// another
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int l = 0, r = n-1;
        while(l <= r) {
          	int mid = l + (r-l)/2;
          	if(nums[mid] == mid) l = mid + 1;
          	else r = mid - 1;
        }
        return l;
    }
};
```



```python
# python3
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        i,j=0,len(nums)-1
        while i<=j:
            m=(i+j)//2
            if nums[m]==m:i=m+1
            else:j=m-1
        return i
```



#### [54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/) [EASY]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int kthLargest(TreeNode* root, int k) {
        stack<TreeNode*> st;
        int cnt = 0;
        while(!st.empty() || root) {
            while(root) {
                st.push(root);
                root = root->right;
            }
            root = st.top();
            st.pop();
            ++cnt;
            if(cnt == k) return root->val;
            root = root->left;
        }
        return 0;
    }
};
```



```python
# python3
class Solution:
    def kthLargest(self, root: TreeNode, k: int) -> int:
        self.res,self.k=None,k

        def dfs(root):
            if not root:
                return
            else:
                dfs(root.right)
                self.k-=1
                if self.k==0:
                    self.res=root.val
                elif self.k>0:
                    dfs(root.left)

        dfs(root)
        return self.res
```



#### [55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/) [EASY]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```



```python
# python3
class Solution:
  def 
```



#### [55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/) [EASY]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int helper(TreeNode* root) {
        if(!root) return 0;
        int left = helper(root->left);
        if(left == -1) return -1;
        int right = helper(root->right);
        if(right == -1) return -1;
        return abs(left - right)<=1 ? max(left, right)+1 : -1; 
    }
    bool isBalanced(TreeNode* root) {
        if(!root) return true;
        return helper(root) != -1;
    }
};
```



```python
# python3
```



#### [56 - II. 数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)  [MID]

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(int i = 0; i < 32; ++i) {
            int p = 1 << i;
            int cnt = 0;
            for(auto v : nums) {
                if(v&p) ++cnt;
            }
            if(cnt%3) res |= p;
        }
        return res;
    }
};

    int singleNumber(vector<int>& nums) {
        int a = 0, b = 0;
        for (int c : nums) {
            int tempA = (~a & b & c) + (a & ~b & ~c);
            b = (~a & ~b & c) + (~a & b & ~c);
            a = tempA;
        }
        return b;
    }
```



```python
# python3
#56-I的解答：一个数组，只有两个数字只出现一次，其他的都出现了两次，找出这两个数
class Solution:
    def singleNumbers(self, nums: List[int]) -> List[int]:
        res,a,b=0,0,0
        for num in nums:
            res^=num
        s=1
        while(res&s==0):
            s<<=1
        for num in nums:
            if(s&num==0):
                a^=num
            else:
                b^=num
        return [a,b]

#56-II的解答
#Method1：dict{"key":"value"}
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        dict={}
        for num in nums:
            if num not in dict:
                dict[num]=1
            else:
                dict[num]+=1
        for num in dict:
            if dict[num]==1:
                return num
           
#Method2: bit operation


         
```



#### [57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/) [EASY]

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        vector<int> res;
        if(!n) return res;
        int l = 0, r = n-1;
        while(l <= r) {
            if(nums[l] + nums[r] == target) {
                res.push_back(nums[l]);
                res.push_back(nums[r]);
                return res;
            } else if (nums[l] + nums[r] < target) {
                ++l;
            } else --r;
        }
        return res;
    }
};
```



```python
# python3
class Solution:
    def twoSum(self,nums:List[int],target:int)->List[int]:
        i,j=0,len(nums)-1
        while i<j:
            s=nums[i]+nums[j]
            if s>target:j-=1
            elif s<target:i+=1
            else:
                return nums[i],nums[j]
        return []
```



#### [57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/) [EASY]

```c++
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        vector<vector<int>> res;
        if(target == 1) return res;
        int l = 1, r = 1;
        while(l <= target/2) {	// = 因为target可能是奇数
            int sum = (l+r)*(r-l+1)/2;
            if(sum == target) {
                vector<int> t;
                for(int i = l; i<=r; ++i) t.emplace_back(i);
                res.emplace_back(t);
                ++l;
            } else if(sum < target) ++r;
            else ++l;
        }
        return res;
    }
};
```



```python
# python3
class Solution:
    def findContinuousSequence(self, target: int) -> List[List[int]]:
        # 初始化窗口指针和输出列表
        i, j, res = 1,2, []

        # 滑动窗口的右边界不能超过target的中值
        while j <= target//2 + 1:
            # 计算当前窗口内数字之和
            cur_sum = sum(list(range(i,j+1)))
            # 若和小于目标，右指针向右移动，扩大窗口
            if cur_sum < target:
                j += 1
            # 若和大于目标，左指针向右移动，减小窗口
            elif cur_sum > target:
                i += 1
            # 相等就把指针形成的窗口添加进输出列表中
            # 别忘了，这里还要继续扩大寻找下一个可能的窗口哦
            else:
                res.append(list(range(i,j+1)))
                # 这里用j+=1，i+=1，i+=2都可以的
                j += 1
        return res
```



#### [58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/) [EASY]

```c++
class Solution {
public:
    string reverseWords(string s) {
        int n = s.size(), cnt = 0;
        string res;
        for(int i = n-1; i >= 0; --i) {
            if(s[i] == ' ') {
                if(!cnt) continue;
                res += s.substr(i+1, cnt) + " ";
                cnt = 0;
            } else ++cnt;
        }
        if(cnt) res += s.substr(0, cnt) + " ";
        if(res.size()>0) res.erase(res.size()-1,1);
        return res;
    }
/*
    string reverseWords(string s) {
        int n = s.size(), cnt = 0;
        string res, sub;
        bool f = true;
        for(int i = n-1; i >= 0; --i) {
            if(s[i] == ' ') {
                if(cnt==0) continue;
                if(f) f = false;
                else res.push_back(' ');
                res += s.substr(i+1, cnt);
                cnt = 0;
            } else ++cnt;
        }
        if(cnt) {
            if(!f) res.push_back(' ');
            res += s.substr(0, cnt);
        }
        return res;
    }
*/
};
```



```python
# python3
class Solution:
    def reverseWords(self, s: str) -> str:
        s=s.strip()
        i=j=len(s)-1
        res=[]
        while i>=0:
            while i>=0 and s[i]!=' ':i-=1
            res.append(s[i+1:j+1])
            while s[i]==' ':i-=1
            j=i
        return ' '.join(res)
```



#### [58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/) [EASY]

```c++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        reverse(s.begin(), s.begin()+n);
        reverse(s.begin()+n, s.end());
        reverse(s.begin(), s.end());
        return s;
    }
};
```



```python
# python3
#slice
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        return s[n:] + s[:n]

#list
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        res = []
        for i in range(n, len(s)):
            res.append(s[i])
        for i in range(n):
            res.append(s[i])
        return ''.join(res)


#string 字符串不可以改拜年，但是可以进行拼接
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        res = ""
        for i in range(n, len(s)):
            res += s[i]
        for i in range(n):
            res += s[i]
        return res

```



#### [59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/) [EASY]

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;
        deque<int> dq;		// 保存下标
        int n = nums.size();
        for(int i = 0; i < n; ++i) {
            while(!dq.empty() && dq.front() <= i-k) {
                dq.pop_front();
            }
            while(!dq.empty() && nums[dq.back()] < nums[i]) dq.pop_back();
            dq.push_back(i);
            if(i >= k-1) res.push_back(nums[dq.front()]);
        }
        return res;
    }
};
```



```python
# python3
```



#### [59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/) [MID]

```c++
class MaxQueue {
public:
    queue<int> q;
    deque<int> mq;   // mq单调递减
    MaxQueue() {
    }
    
    int max_value() {
        if(q.empty()) return -1;
        return mq.front();
    }
    
    void push_back(int value) {
        q.push(value);
        while(!mq.empty() && mq.back() < value) mq.pop_back();
        mq.push_back(value);
    }
    
    int pop_front() {
        if(q.empty()) return -1;
        int v = q.front();
        q.pop();
        if(v >= mq.front()) mq.pop_front();
        return v;
    }
};
```



```python
# python3
```



#### [60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/) [EASY]

```c++
class Solution {
public:
    vector<double> twoSum(int n) {
        vector<vector<int>> dp(15, vector<int>(70));
        for(int i = 1; i <= 6; ++i) dp[1][i] = 1;
        for(int i = 2; i <= n; ++i) {
            for(int j = 1*i; j <= 6*i; ++j) {
                for(int k = 1; k <= 6; ++k) {
                    if(j - k <= 0) break;
                    dp[i][j] += dp[i-1][j-k];
                }
            }
        }
        int all = pow(6, n);
        vector<double> res;
        for(int i = n; i <= 6*n; ++i) {
            res.push_back(dp[n][i]*1.0/all);
        }
        return res;
    }
};
```



```python
# python3
```



#### [61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/) [EASY]

```c++
class Solution {
public:
    bool isStraight(vector<int>& nums) {
        int minv = INT_MAX, maxv = INT_MIN;
        vector<bool> vis(15);
        for(auto v : nums) {
            if(v) {
                if(vis[v]) return false;
                else vis[v] = true;
                minv = min(v, minv);
                maxv = max(v, maxv);
            }
        }
        return (maxv - minv) < 5;
    }
};
```



```python
# python3
#法一
class Solution:
    def isStraight(self, nums: List[int]) -> bool:
        joker = 0
        nums.sort() # 数组排序
        for i in range(4):
            if nums[i] == 0: joker += 1 # 统计大小王数量
            elif nums[i] == nums[i + 1]: return False # 若有重复，提前返回 false
        return nums[4] - nums[joker] < 5 # 最大牌 - 最小牌 < 5 则可构成顺子
      
#法二
class Solution:
    def isStraight(self, nums: List[int]) -> bool:
        repeat=set()
        ma,mi=0,14
        for num in nums:
            if num==0:continue
            ma=max(ma,num)
            mi=min(mi,num)
            if num in repeat:return False
            repeat.add(num)
        return ma-mi<5
```



#### [62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/) [EASY]

```c++
class Solution {
public:
    int lastRemaining(int n, int m) {
        int ans = 0;
        // 最后一轮剩下2个人，所以从2开始反推
        for (int i = 2; i <= n; i++) {
            ans = (ans + m) % i;
        }
        return ans;
    }
};
```



```python
# python3
```



#### [63. 股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/) [MID]

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minv = INT_MAX, res = 0;
        for(auto v : prices) {
            if(minv == INT_MAX) minv = v;
            res = max(res, v-minv);
            minv = min(minv, v);
        }
        return res;
    }
};
```



```python
# python3
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if prices==[]:return 0
        res=0
        minv=prices[0]
        for i in range(1,len(prices)):
            minv=min(minv,prices[i])
            res=max(res,prices[i]-minv)
        return res
```



#### [64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/) [MID]

```c++
class Solution {
public:
    int sumNums(int n) {
        n && (n += sumNums(n-1));
        return n;
    }
};
```



```python
# python3
class Solution:
    def __init__(self):
        self.res = 0

    def sumNums(self, n: int) -> int:
        n>1 and self.sumNums(n-1)
        self.res+=n
        return self.res
```



#### [65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/) [EASY]

```c++
class Solution {
public:
    int add(int a, int b) {
        while (b) {
            int carry = (unsigned int)(a & b) << 1;
            a ^= b;		// 求和
            b = carry;
        }
        return a;
    }
};
```



```python
# python3
```



#### [66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/) [EASY]

```c++
class Solution {
public:
    vector<int> constructArr(vector<int>& a) {
        int n = a.size();
        vector<int> b(n, 1);
        for(int i = 1; i < n; ++i) {
            b[i] = b[i-1] * a[i-1]; // b[1] = a[0]; b[n-1] = ...*a[n-2];
        }
        for(int i = n-2; i >= 0; --i) {
            a[i] = a[i] * a[i+1];
            b[i] = b[i] * a[i+1];
        }
        /*
        for(int i = 1; i < n; ++i) {
            a[n-i-1] = a[n-i-1] * a[n-i];
        }
        for(int i = 0; i < n-1; ++i) {
            b[i] *= a[i+1];
        }
        */
        return b;
    }
};
```



```python
#python3
class Solution:
    def constructArr(self, a: List[int]) -> List[int]:
      

```



#### [67. 把字符串转换成整数](https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/) [MID]

```c++
class Solution {
public:
    int strToInt(string str) {
        int n = str.size(), p = 0;
        if(!n) return 0;
        while(p < n && str[p] == ' ') ++p;
        if(p == n) return 0;
        
        int flag = 1;
        if(str[p] == '+') ++p;  // ++p, flag = 1;
        else if(str[p] == '-') flag = -1, ++p;

        int res = 0, v;
        while(p < n && str[p] <= '9' && str[p] >= '0') {
            v = str[p] - '0';
            if(res > INT_MAX/10 || res == INT_MAX/10 && v > 7) return INT_MAX;
            if(res < INT_MIN/10 || res == INT_MIN/10 && v > 8) return INT_MIN;
            res = res*10 + v*flag;
            ++p;
        }
        return res;
    }
};
```



```python
# python3
class Solution:
    def strToInt(self, str: str) -> int:
        str=str.strip()
        if not str:return 0
        res,i,flag,max_int=0,1,1,2**31-1
        if str[0]=='-':flag=-1
        elif str[0]!='+':i=0
        for c in str[i:]:
            if not '0'<=c<='9':break
            res=10*res+ord(c)-ord('0')
            if res>max_int:
                return max_int if flag==1 else -max_int-1
        return flag*res  
```



#### [68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/) [EASY]

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root) return nullptr;
        if((root->val - p->val) * (root->val - q->val) <= 0) return root;
        else if(root->val < p->val) return lowestCommonAncestor(root->right, p, q);
        else return lowestCommonAncestor(root->left, p, q);
    }
};

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root == p || root == q) return root;
        TreeNode* l = lowestCommonAncestor(root->left, p, q);
        TreeNode* r = lowestCommonAncestor(root->right, p, q);
        if(l&&r) return root;
        if(l) return l;
        else return r;
    }
};
```



```python
# python3
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        while root:
            if root.val <p.val and root.val <q.val:
                root=root.right
            elif root.val>p.val and root.val >q.val:
                root=root.left
            else:break
        return root
```



#### [68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/) [EASY]

```c++
// 同上
```

```python
# python3
class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
      	if not root or root==p or root==q:return root
        left=self.lowestCommonAncestor(root.left,p,q)
        right=self.lowestCommonAncestor(root.right,p,q)
        if not left and not right:return None
        if not left:return right
        if not right:return left
        return root
      
```

